// Code generated by protoc-gen-gogo.
// source: messages.proto
// DO NOT EDIT!

package apipb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"

// discarding unused import gogoproto "gogoproto"

import gopkg_in_mgo_v2_bson "gopkg.in/mgo.v2/bson"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Gender int32

const (
	Gender_UNKNOWN Gender = 0
	Gender_MALE    Gender = 1
	Gender_FEMALE  Gender = 2
)

var Gender_name = map[int32]string{
	0: "UNKNOWN",
	1: "MALE",
	2: "FEMALE",
}
var Gender_value = map[string]int32{
	"UNKNOWN": 0,
	"MALE":    1,
	"FEMALE":  2,
}

func (x Gender) String() string {
	return proto.EnumName(Gender_name, int32(x))
}
func (Gender) EnumDescriptor() ([]byte, []int) { return fileDescriptorMessages, []int{0} }

type ReleaseState int32

const (
	ReleaseState_CREATED     ReleaseState = 0
	ReleaseState_DEVELOPMENT ReleaseState = 1
	ReleaseState_WAITING     ReleaseState = 2
	ReleaseState_REJECTED    ReleaseState = 3
	ReleaseState_VALIDATED   ReleaseState = 4
	ReleaseState_PRODUCTION  ReleaseState = 5
)

var ReleaseState_name = map[int32]string{
	0: "CREATED",
	1: "DEVELOPMENT",
	2: "WAITING",
	3: "REJECTED",
	4: "VALIDATED",
	5: "PRODUCTION",
}
var ReleaseState_value = map[string]int32{
	"CREATED":     0,
	"DEVELOPMENT": 1,
	"WAITING":     2,
	"REJECTED":    3,
	"VALIDATED":   4,
	"PRODUCTION":  5,
}

func (x ReleaseState) String() string {
	return proto.EnumName(ReleaseState_name, int32(x))
}
func (ReleaseState) EnumDescriptor() ([]byte, []int) { return fileDescriptorMessages, []int{1} }

type RequestReleaseState int32

const (
	RequestReleaseState_PRODUCTION_STATE RequestReleaseState = 0
	RequestReleaseState_ALL_STATES       RequestReleaseState = 1
)

var RequestReleaseState_name = map[int32]string{
	0: "PRODUCTION_STATE",
	1: "ALL_STATES",
}
var RequestReleaseState_value = map[string]int32{
	"PRODUCTION_STATE": 0,
	"ALL_STATES":       1,
}

func (x RequestReleaseState) String() string {
	return proto.EnumName(RequestReleaseState_name, int32(x))
}
func (RequestReleaseState) EnumDescriptor() ([]byte, []int) { return fileDescriptorMessages, []int{2} }

type GameEntryRequest_RequestType int32

const (
	GameEntryRequest_ADD        GameEntryRequest_RequestType = 0
	GameEntryRequest_ACTIVATE   GameEntryRequest_RequestType = 1
	GameEntryRequest_DEACTIVATE GameEntryRequest_RequestType = 2
	GameEntryRequest_SETTINGS   GameEntryRequest_RequestType = 3
	GameEntryRequest_INDEX      GameEntryRequest_RequestType = 4
)

var GameEntryRequest_RequestType_name = map[int32]string{
	0: "ADD",
	1: "ACTIVATE",
	2: "DEACTIVATE",
	3: "SETTINGS",
	4: "INDEX",
}
var GameEntryRequest_RequestType_value = map[string]int32{
	"ADD":        0,
	"ACTIVATE":   1,
	"DEACTIVATE": 2,
	"SETTINGS":   3,
	"INDEX":      4,
}

func (x GameEntryRequest_RequestType) String() string {
	return proto.EnumName(GameEntryRequest_RequestType_name, int32(x))
}
func (GameEntryRequest_RequestType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorMessages, []int{17, 0}
}

type ListGamesRequest_InnerState int32

const (
	ListGamesRequest_ANY         ListGamesRequest_InnerState = 0
	ListGamesRequest_CREATED     ListGamesRequest_InnerState = 1
	ListGamesRequest_DEVELOPMENT ListGamesRequest_InnerState = 2
	ListGamesRequest_WAITING     ListGamesRequest_InnerState = 3
	ListGamesRequest_REJECTED    ListGamesRequest_InnerState = 4
	ListGamesRequest_VALIDATED   ListGamesRequest_InnerState = 5
	ListGamesRequest_PRODUCTION  ListGamesRequest_InnerState = 6
)

var ListGamesRequest_InnerState_name = map[int32]string{
	0: "ANY",
	1: "CREATED",
	2: "DEVELOPMENT",
	3: "WAITING",
	4: "REJECTED",
	5: "VALIDATED",
	6: "PRODUCTION",
}
var ListGamesRequest_InnerState_value = map[string]int32{
	"ANY":         0,
	"CREATED":     1,
	"DEVELOPMENT": 2,
	"WAITING":     3,
	"REJECTED":    4,
	"VALIDATED":   5,
	"PRODUCTION":  6,
}

func (x ListGamesRequest_InnerState) String() string {
	return proto.EnumName(ListGamesRequest_InnerState_name, int32(x))
}
func (ListGamesRequest_InnerState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorMessages, []int{21, 0}
}

type Address struct {
	StreetAddress string `protobuf:"bytes,1,opt,name=street_address,json=streetAddress,proto3" json:"street_address,omitempty" bson:"street_address,omitempty"`
	City          string `protobuf:"bytes,2,opt,name=city,proto3" json:"city,omitempty" bson:"city,omitempty"`
	State         string `protobuf:"bytes,3,opt,name=state,proto3" json:"state,omitempty" bson:"state,omitempty"`
	ZipCode       string `protobuf:"bytes,4,opt,name=zip_code,json=zipCode,proto3" json:"zip_code,omitempty" bson:"zip_code,omitempty"`
	CountryCode   string `protobuf:"bytes,5,opt,name=country_code,json=countryCode,proto3" json:"country_code,omitempty" bson:"country_code,omitempty"`
}

func (m *Address) Reset()                    { *m = Address{} }
func (m *Address) String() string            { return proto.CompactTextString(m) }
func (*Address) ProtoMessage()               {}
func (*Address) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{0} }

type Profile struct {
	Id          gopkg_in_mgo_v2_bson.ObjectId `protobuf:"bytes,1,opt,name=id,proto3,customtype=gopkg.in/mgo.v2/bson.ObjectId" json:"id" bson:"_id,omitempty"`
	Email       string                        `protobuf:"bytes,2,opt,name=email,proto3" json:"email,omitempty" bson:"email,omitempty"`
	FirstName   string                        `protobuf:"bytes,3,opt,name=first_name,json=firstName,proto3" json:"first_name,omitempty" bson:"first_name,omitempty"`
	LastName    string                        `protobuf:"bytes,4,opt,name=last_name,json=lastName,proto3" json:"last_name,omitempty" bson:"last_name,omitempty"`
	Language    string                        `protobuf:"bytes,5,opt,name=language,proto3" json:"language,omitempty" bson:"language,omitempty"`
	MobilePhone string                        `protobuf:"bytes,6,opt,name=mobile_phone,json=mobilePhone,proto3" json:"mobile_phone,omitempty" bson:"mobile_phone,omitempty"`
	Address     *Address                      `protobuf:"bytes,7,opt,name=address" json:"address,omitempty" bson:"address,omitempty"`
	CreatedAt   int64                         `protobuf:"varint,8,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty" bson:"created_at,omitempty"`
	LastUpdated int64                         `protobuf:"varint,9,opt,name=last_updated,json=lastUpdated,proto3" json:"last_updated,omitempty" bson:"last_updated,omitempty"`
}

func (m *Profile) Reset()                    { *m = Profile{} }
func (m *Profile) String() string            { return proto.CompactTextString(m) }
func (*Profile) ProtoMessage()               {}
func (*Profile) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{1} }

type ChildGameEntry struct {
	Id                  gopkg_in_mgo_v2_bson.ObjectId `protobuf:"bytes,1,opt,name=id,proto3,customtype=gopkg.in/mgo.v2/bson.ObjectId" json:"id" bson:"id"`
	Active              bool                          `protobuf:"varint,2,opt,name=active,proto3" json:"active,omitempty" bson:"active"`
	DashboardIndex      int32                         `protobuf:"varint,3,opt,name=dashboard_index,json=dashboardIndex,proto3" json:"dashboard_index,omitempty" bson:"dashboard_index"`
	Settings            []byte                        `protobuf:"bytes,4,opt,name=settings,proto3" json:"settings,omitempty" bson:"settings"`
	AddedAt             int64                         `protobuf:"varint,5,opt,name=added_at,json=addedAt,proto3" json:"added_at,omitempty" bson:"added_at"`
	ActivationChangedAt int64                         `protobuf:"varint,6,opt,name=activation_changed_at,json=activationChangedAt,proto3" json:"activation_changed_at,omitempty" bson:"activation_changed_at"`
	UpdatedAt           int64                         `protobuf:"varint,7,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty" bson:"updated_at"`
}

func (m *ChildGameEntry) Reset()                    { *m = ChildGameEntry{} }
func (m *ChildGameEntry) String() string            { return proto.CompactTextString(m) }
func (*ChildGameEntry) ProtoMessage()               {}
func (*ChildGameEntry) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{2} }

type Child struct {
	Id            gopkg_in_mgo_v2_bson.ObjectId `protobuf:"bytes,1,opt,name=id,proto3,customtype=gopkg.in/mgo.v2/bson.ObjectId" json:"id" bson:"_id,omitempty"`
	ParentId      gopkg_in_mgo_v2_bson.ObjectId `protobuf:"bytes,2,opt,name=parent_id,json=parentId,proto3,customtype=gopkg.in/mgo.v2/bson.ObjectId" json:"parent_id" bson:"parent_id,omitempty"`
	FirstName     string                        `protobuf:"bytes,3,opt,name=first_name,json=firstName,proto3" json:"first_name,omitempty" bson:"first_name,omitempty"`
	LastName      string                        `protobuf:"bytes,4,opt,name=last_name,json=lastName,proto3" json:"last_name,omitempty" bson:"last_name,omitempty"`
	BirthDay      int64                         `protobuf:"varint,5,opt,name=birth_day,json=birthDay,proto3" json:"birth_day,omitempty" bson:"birth_day,omitempty"`
	Gender        Gender                        `protobuf:"varint,7,opt,name=gender,proto3,enum=apipb.Gender" json:"gender,omitempty" bson:"gender,omitempty"`
	Language      string                        `protobuf:"bytes,8,opt,name=language,proto3" json:"language,omitempty" bson:"language,omitempty"`
	Games         []*ChildGameEntry             `protobuf:"bytes,9,rep,name=games" json:"games,omitempty" bson:"games,omitempty"`
	Active        bool                          `protobuf:"varint,10,opt,name=active,proto3" json:"active,omitempty" bson:"active,omitempty"`
	LoggedIn      bool                          `protobuf:"varint,11,opt,name=logged_in,json=loggedIn,proto3" json:"logged_in,omitempty" bson:"logged_in,omitempty"`
	SoundsEnabled bool                          `protobuf:"varint,12,opt,name=sounds_enabled,json=soundsEnabled,proto3" json:"sounds_enabled,omitempty" bson:"sounds_enabled,omitempty"`
	CreatedAt     int64                         `protobuf:"varint,15,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty" bson:"created_at,omitempty"`
	LastUpdated   int64                         `protobuf:"varint,16,opt,name=last_updated,json=lastUpdated,proto3" json:"last_updated,omitempty" bson:"last_updated,omitempty"`
}

func (m *Child) Reset()                    { *m = Child{} }
func (m *Child) String() string            { return proto.CompactTextString(m) }
func (*Child) ProtoMessage()               {}
func (*Child) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{3} }

type Author struct {
	Name  string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty" bson:"name,omitempty"`
	Email string `protobuf:"bytes,2,opt,name=email,proto3" json:"email,omitempty" bson:"email,omitempty"`
}

func (m *Author) Reset()                    { *m = Author{} }
func (m *Author) String() string            { return proto.CompactTextString(m) }
func (*Author) ProtoMessage()               {}
func (*Author) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{4} }

type GameMetadata struct {
	Language string `protobuf:"bytes,1,opt,name=language,proto3" json:"language,omitempty" bson:"language,omitempty"`
	// Visible Name
	VisibleName string `protobuf:"bytes,2,opt,name=visible_name,json=visibleName,proto3" json:"visible_name,omitempty" bson:"visible_name,omitempty"`
	// Summary is summary of game
	Summary string `protobuf:"bytes,3,opt,name=summary,proto3" json:"summary,omitempty" bson:"summary,omitempty"`
	// Description
	Description string `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty" bson:"description,omitempty"`
	// Logo is a rectangle image
	Logo string `protobuf:"bytes,5,opt,name=logo,proto3" json:"logo,omitempty" bson:"logo,omitempty"`
	// Icon is a square image
	Icon string `protobuf:"bytes,6,opt,name=icon,proto3" json:"icon,omitempty" bson:"icon,omitempty"`
	// Keywords
	Keywords []string `protobuf:"bytes,7,rep,name=keywords" json:"keywords,omitempty" bson:"keywords,omitempty"`
	// Images are image files that show on market
	Images []string `protobuf:"bytes,8,rep,name=images" json:"images,omitempty" bson:"images,omitempty"`
	// InfoSlug is the id of the content which describes how to play this game
	InfoSlug string `protobuf:"bytes,9,opt,name=info_slug,json=infoSlug,proto3" json:"info_slug,omitempty" bson:"info_slug,omitempty"`
	// Assets are asset folders or paths for this language
	Assets []string `protobuf:"bytes,10,rep,name=assets" json:"assets,omitempty" bson:"assets,omitempty"`
}

func (m *GameMetadata) Reset()                    { *m = GameMetadata{} }
func (m *GameMetadata) String() string            { return proto.CompactTextString(m) }
func (*GameMetadata) ProtoMessage()               {}
func (*GameMetadata) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{5} }

type GameManifest struct {
	// Unique Name of game
	UniqueName string `protobuf:"bytes,1,opt,name=unique_name,json=uniqueName,proto3" json:"unique_name,omitempty" bson:"unique_name,omitempty" cli:"Unique Name"`
	// Licence
	Licence string `protobuf:"bytes,2,opt,name=licence,proto3" json:"licence,omitempty" bson:"licence,omitempty" cli:"Licence"`
	// Languages
	Languages []string `protobuf:"bytes,3,rep,name=languages" json:"languages,omitempty" bson:"languages,omitempty"`
	// Homepage is the website of game
	Homepage string `protobuf:"bytes,4,opt,name=homepage,proto3" json:"homepage,omitempty" bson:"homepage,omitempty"`
	// Main points to index.html file
	Main string `protobuf:"bytes,5,opt,name=main,proto3" json:"main,omitempty" bson:"main" cli:"Main"`
	// Version is current version for using on manifest file
	Version string `protobuf:"bytes,6,opt,name=version,proto3" json:"version,omitempty" bson:"version" cli:"Version"`
	// Authors is for using at manifest file
	Authors []*Author `protobuf:"bytes,7,rep,name=authors" json:"authors,omitempty" bson:"authors"`
	// Repository
	Repository string `protobuf:"bytes,8,opt,name=repository,proto3" json:"repository,omitempty" bson:"repository"`
	// Metadata information for each languages
	Metadata []*GameMetadata `protobuf:"bytes,13,rep,name=metadata" json:"metadata,omitempty" bson:"metadata,omitempty"`
	// Exclude directories when building
	Exclude []string `protobuf:"bytes,14,rep,name=exclude" json:"exclude,omitempty" bson:"exclude"`
	// Settings.json path
	Settings string `protobuf:"bytes,15,opt,name=settings,proto3" json:"settings,omitempty" bson:"settings,omitempty"`
	// KV directory path
	KvPath string `protobuf:"bytes,16,opt,name=kv_path,json=kvPath,proto3" json:"kv_path,omitempty" bson:"kv_path,omitempty"`
	// DeveloperName is the visible developer name
	DeveloperName string `protobuf:"bytes,17,opt,name=developer_name,json=developerName,proto3" json:"developer_name,omitempty" bson:"developer_name,omitempty"`
	// DefaultLanguage
	DefaultLanguage string `protobuf:"bytes,18,opt,name=default_language,json=defaultLanguage,proto3" json:"default_language,omitempty" bson:"default_language,omitempty"`
}

func (m *GameManifest) Reset()                    { *m = GameManifest{} }
func (m *GameManifest) String() string            { return proto.CompactTextString(m) }
func (*GameManifest) ProtoMessage()               {}
func (*GameManifest) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{6} }

type Game struct {
	Id                gopkg_in_mgo_v2_bson.ObjectId `protobuf:"bytes,1,opt,name=id,proto3,customtype=gopkg.in/mgo.v2/bson.ObjectId" json:"id" bson:"_id,omitempty"`
	UniqueName        string                        `protobuf:"bytes,2,opt,name=unique_name,json=uniqueName,proto3" json:"unique_name,omitempty" bson:"unique_name,omitempty"`
	OwnerId           gopkg_in_mgo_v2_bson.ObjectId `protobuf:"bytes,3,opt,name=owner_id,json=ownerId,proto3,customtype=gopkg.in/mgo.v2/bson.ObjectId" json:"owner_id" bson:"owner_id,omitempty"`
	ProductionVersion string                        `protobuf:"bytes,4,opt,name=production_version,json=productionVersion,proto3" json:"production_version,omitempty" bson:"production_version,omitempty"`
	IsOnProduction    bool                          `protobuf:"varint,5,opt,name=is_on_production,json=isOnProduction,proto3" json:"is_on_production,omitempty" bson:"is_on_production,omitempty"`
	CreatedAt         int64                         `protobuf:"varint,6,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty" bson:"created_at,omitempty"`
	LastUpdated       int64                         `protobuf:"varint,7,opt,name=last_updated,json=lastUpdated,proto3" json:"last_updated,omitempty" bson:"last_updated,omitempty"`
}

func (m *Game) Reset()                    { *m = Game{} }
func (m *Game) String() string            { return proto.CompactTextString(m) }
func (*Game) ProtoMessage()               {}
func (*Game) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{7} }

type GameRelease struct {
	ReleaseId     gopkg_in_mgo_v2_bson.ObjectId `protobuf:"bytes,1,opt,name=release_id,json=releaseId,proto3,customtype=gopkg.in/mgo.v2/bson.ObjectId" json:"release_id" bson:"_id"`
	GameId        gopkg_in_mgo_v2_bson.ObjectId `protobuf:"bytes,2,opt,name=game_id,json=gameId,proto3,customtype=gopkg.in/mgo.v2/bson.ObjectId" json:"game_id" bson:"game_id"`
	Version       string                        `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty" bson:"version"`
	GameManifest  *GameManifest                 `protobuf:"bytes,4,opt,name=game_manifest,json=gameManifest" json:"game_manifest,omitempty" bson:"game_manifest,omitempty"`
	ReleasedAt    int64                         `protobuf:"varint,5,opt,name=released_at,json=releasedAt,proto3" json:"released_at,omitempty" bson:"released_at"`
	ReleasedBy    gopkg_in_mgo_v2_bson.ObjectId `protobuf:"bytes,6,opt,name=released_by,json=releasedBy,proto3,customtype=gopkg.in/mgo.v2/bson.ObjectId" json:"released_by" bson:"released_by,omitempty"`
	ReleaseState  ReleaseState                  `protobuf:"varint,7,opt,name=release_state,json=releaseState,proto3,enum=apipb.ReleaseState" json:"release_state,omitempty" bson:"release_state"`
	ValidatedBy   gopkg_in_mgo_v2_bson.ObjectId `protobuf:"bytes,8,opt,name=validated_by,json=validatedBy,proto3,customtype=gopkg.in/mgo.v2/bson.ObjectId" json:"validated_by" bson:"validated_by,omitempty"`
	ValidatedAt   int64                         `protobuf:"varint,9,opt,name=validated_at,json=validatedAt,proto3" json:"validated_at,omitempty" bson:"validated_at"`
	IntVersion    int64                         `protobuf:"varint,10,opt,name=int_version,json=intVersion,proto3" json:"int_version,omitempty" bson:"int_version"`
	Storage       string                        `protobuf:"bytes,11,opt,name=storage,proto3" json:"storage,omitempty" bson:"-"`
	ArchiveFormat string                        `protobuf:"bytes,12,opt,name=archive_format,json=archiveFormat,proto3" json:"archive_format,omitempty" bson:"-"`
}

func (m *GameRelease) Reset()                    { *m = GameRelease{} }
func (m *GameRelease) String() string            { return proto.CompactTextString(m) }
func (*GameRelease) ProtoMessage()               {}
func (*GameRelease) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{8} }

type UploadToken struct {
	Token      string                        `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty" bson:"token,omitempty"`
	ExpiresAt  int64                         `protobuf:"varint,2,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty" bson:"expires_at,omitempty"`
	UserId     gopkg_in_mgo_v2_bson.ObjectId `protobuf:"bytes,3,opt,name=user_id,json=userId,proto3,customtype=gopkg.in/mgo.v2/bson.ObjectId" json:"user_id" bson:"user_id,omitempty"`
	GameId     gopkg_in_mgo_v2_bson.ObjectId `protobuf:"bytes,4,opt,name=game_id,json=gameId,proto3,customtype=gopkg.in/mgo.v2/bson.ObjectId" json:"game_id" bson:"game_id,omitempty"`
	NewVersion string                        `protobuf:"bytes,5,opt,name=new_version,json=newVersion,proto3" json:"new_version,omitempty" bson:"new_version,omitempty"`
	UploadTo   string                        `protobuf:"bytes,6,opt,name=upload_to,json=uploadTo,proto3" json:"upload_to,omitempty" bson:"upload_to,omitempty"`
}

func (m *UploadToken) Reset()                    { *m = UploadToken{} }
func (m *UploadToken) String() string            { return proto.CompactTextString(m) }
func (*UploadToken) ProtoMessage()               {}
func (*UploadToken) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{9} }

type GetProfileRequest struct {
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *GetProfileRequest) Reset()                    { *m = GetProfileRequest{} }
func (m *GetProfileRequest) String() string            { return proto.CompactTextString(m) }
func (*GetProfileRequest) ProtoMessage()               {}
func (*GetProfileRequest) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{10} }

type GetChildRequest struct {
	ChildId string `protobuf:"bytes,1,opt,name=child_id,json=childId,proto3" json:"child_id,omitempty"`
}

func (m *GetChildRequest) Reset()                    { *m = GetChildRequest{} }
func (m *GetChildRequest) String() string            { return proto.CompactTextString(m) }
func (*GetChildRequest) ProtoMessage()               {}
func (*GetChildRequest) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{11} }

type GetChildrenFromProfileRequest struct {
	ProfileId string `protobuf:"bytes,1,opt,name=profile_id,json=profileId,proto3" json:"profile_id,omitempty"`
}

func (m *GetChildrenFromProfileRequest) Reset()         { *m = GetChildrenFromProfileRequest{} }
func (m *GetChildrenFromProfileRequest) String() string { return proto.CompactTextString(m) }
func (*GetChildrenFromProfileRequest) ProtoMessage()    {}
func (*GetChildrenFromProfileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorMessages, []int{12}
}

type ChangeChildActivationRequest struct {
	ChildId string `protobuf:"bytes,1,opt,name=child_id,json=childId,proto3" json:"child_id,omitempty"`
	Active  bool   `protobuf:"varint,2,opt,name=active,proto3" json:"active,omitempty"`
}

func (m *ChangeChildActivationRequest) Reset()         { *m = ChangeChildActivationRequest{} }
func (m *ChangeChildActivationRequest) String() string { return proto.CompactTextString(m) }
func (*ChangeChildActivationRequest) ProtoMessage()    {}
func (*ChangeChildActivationRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorMessages, []int{13}
}

type GetChildrenFromProfileResponse struct {
	Children []*Child `protobuf:"bytes,1,rep,name=children" json:"children,omitempty"`
}

func (m *GetChildrenFromProfileResponse) Reset()         { *m = GetChildrenFromProfileResponse{} }
func (m *GetChildrenFromProfileResponse) String() string { return proto.CompactTextString(m) }
func (*GetChildrenFromProfileResponse) ProtoMessage()    {}
func (*GetChildrenFromProfileResponse) Descriptor() ([]byte, []int) {
	return fileDescriptorMessages, []int{14}
}

type GetGameReleaseRequest struct {
	GameId  string              `protobuf:"bytes,1,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
	Version string              `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	State   RequestReleaseState `protobuf:"varint,3,opt,name=state,proto3,enum=apipb.RequestReleaseState" json:"state,omitempty"`
}

func (m *GetGameReleaseRequest) Reset()                    { *m = GetGameReleaseRequest{} }
func (m *GetGameReleaseRequest) String() string            { return proto.CompactTextString(m) }
func (*GetGameReleaseRequest) ProtoMessage()               {}
func (*GetGameReleaseRequest) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{15} }

type SoundEnableRequest struct {
	ChildId   string `protobuf:"bytes,1,opt,name=child_id,json=childId,proto3" json:"child_id,omitempty"`
	ProfileId string `protobuf:"bytes,2,opt,name=profile_id,json=profileId,proto3" json:"profile_id,omitempty"`
	Enable    bool   `protobuf:"varint,3,opt,name=enable,proto3" json:"enable,omitempty"`
}

func (m *SoundEnableRequest) Reset()                    { *m = SoundEnableRequest{} }
func (m *SoundEnableRequest) String() string            { return proto.CompactTextString(m) }
func (*SoundEnableRequest) ProtoMessage()               {}
func (*SoundEnableRequest) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{16} }

type GameEntryRequest struct {
	ChildId  string                       `protobuf:"bytes,1,opt,name=child_id,json=childId,proto3" json:"child_id,omitempty"`
	GameId   string                       `protobuf:"bytes,2,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
	Type     GameEntryRequest_RequestType `protobuf:"varint,3,opt,name=type,proto3,enum=apipb.GameEntryRequest_RequestType" json:"type,omitempty"`
	Settings []byte                       `protobuf:"bytes,4,opt,name=settings,proto3" json:"settings,omitempty"`
	Index    int32                        `protobuf:"varint,5,opt,name=index,proto3" json:"index,omitempty"`
}

func (m *GameEntryRequest) Reset()                    { *m = GameEntryRequest{} }
func (m *GameEntryRequest) String() string            { return proto.CompactTextString(m) }
func (*GameEntryRequest) ProtoMessage()               {}
func (*GameEntryRequest) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{17} }

type PublishResponse struct {
	Type    int32        `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	Message string       `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	Token   *UploadToken `protobuf:"bytes,3,opt,name=token" json:"token,omitempty"`
}

func (m *PublishResponse) Reset()                    { *m = PublishResponse{} }
func (m *PublishResponse) String() string            { return proto.CompactTextString(m) }
func (*PublishResponse) ProtoMessage()               {}
func (*PublishResponse) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{18} }

type ValidateRequest struct {
	GameId      string       `protobuf:"bytes,1,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
	GameVersion string       `protobuf:"bytes,2,opt,name=game_version,json=gameVersion,proto3" json:"game_version,omitempty"`
	NewState    ReleaseState `protobuf:"varint,3,opt,name=new_state,json=newState,proto3,enum=apipb.ReleaseState" json:"new_state,omitempty"`
}

func (m *ValidateRequest) Reset()                    { *m = ValidateRequest{} }
func (m *ValidateRequest) String() string            { return proto.CompactTextString(m) }
func (*ValidateRequest) ProtoMessage()               {}
func (*ValidateRequest) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{19} }

// Get game by game_id or unique_name
type GetGameRequest struct {
	UniqueName string `protobuf:"bytes,1,opt,name=unique_name,json=uniqueName,proto3" json:"unique_name,omitempty"`
	GameId     string `protobuf:"bytes,2,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
}

func (m *GetGameRequest) Reset()                    { *m = GetGameRequest{} }
func (m *GetGameRequest) String() string            { return proto.CompactTextString(m) }
func (*GetGameRequest) ProtoMessage()               {}
func (*GetGameRequest) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{20} }

type ListGamesRequest struct {
	ReleaseState ListGamesRequest_InnerState `protobuf:"varint,1,opt,name=release_state,json=releaseState,proto3,enum=apipb.ListGamesRequest_InnerState" json:"release_state,omitempty"`
	Limit        int32                       `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
	Offset       int32                       `protobuf:"varint,3,opt,name=offset,proto3" json:"offset,omitempty"`
}

func (m *ListGamesRequest) Reset()                    { *m = ListGamesRequest{} }
func (m *ListGamesRequest) String() string            { return proto.CompactTextString(m) }
func (*ListGamesRequest) ProtoMessage()               {}
func (*ListGamesRequest) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{21} }

type ListItem struct {
	GameId            string       `protobuf:"bytes,1,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
	UniqueName        string       `protobuf:"bytes,2,opt,name=unique_name,json=uniqueName,proto3" json:"unique_name,omitempty"`
	LatestVersion     string       `protobuf:"bytes,3,opt,name=latest_version,json=latestVersion,proto3" json:"latest_version,omitempty"`
	LatestState       ReleaseState `protobuf:"varint,4,opt,name=latest_state,json=latestState,proto3,enum=apipb.ReleaseState" json:"latest_state,omitempty"`
	ProductionVersion string       `protobuf:"bytes,5,opt,name=production_version,json=productionVersion,proto3" json:"production_version,omitempty"`
	Storage           string       `protobuf:"bytes,6,opt,name=storage,proto3" json:"storage,omitempty"`
	ArchiveFormat     string       `protobuf:"bytes,7,opt,name=archive_format,json=archiveFormat,proto3" json:"archive_format,omitempty"`
}

func (m *ListItem) Reset()                    { *m = ListItem{} }
func (m *ListItem) String() string            { return proto.CompactTextString(m) }
func (*ListItem) ProtoMessage()               {}
func (*ListItem) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{22} }

type GetLatestVersionsRequest struct {
	State   RequestReleaseState `protobuf:"varint,1,opt,name=state,proto3,enum=apipb.RequestReleaseState" json:"state,omitempty"`
	GameIds []string            `protobuf:"bytes,2,rep,name=game_ids,json=gameIds" json:"game_ids,omitempty"`
}

func (m *GetLatestVersionsRequest) Reset()         { *m = GetLatestVersionsRequest{} }
func (m *GetLatestVersionsRequest) String() string { return proto.CompactTextString(m) }
func (*GetLatestVersionsRequest) ProtoMessage()    {}
func (*GetLatestVersionsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptorMessages, []int{23}
}

type GameAndVersion struct {
	GameId     string `protobuf:"bytes,1,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
	Version    string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	TarballUrl string `protobuf:"bytes,3,opt,name=tarball_url,json=tarballUrl,proto3" json:"tarball_url,omitempty"`
}

func (m *GameAndVersion) Reset()                    { *m = GameAndVersion{} }
func (m *GameAndVersion) String() string            { return proto.CompactTextString(m) }
func (*GameAndVersion) ProtoMessage()               {}
func (*GameAndVersion) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{24} }

type GameVersionsResponse struct {
	Results []*GameAndVersion `protobuf:"bytes,1,rep,name=results" json:"results,omitempty"`
}

func (m *GameVersionsResponse) Reset()                    { *m = GameVersionsResponse{} }
func (m *GameVersionsResponse) String() string            { return proto.CompactTextString(m) }
func (*GameVersionsResponse) ProtoMessage()               {}
func (*GameVersionsResponse) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{25} }

// Search Service
type IndexRequest struct {
}

func (m *IndexRequest) Reset()                    { *m = IndexRequest{} }
func (m *IndexRequest) String() string            { return proto.CompactTextString(m) }
func (*IndexRequest) ProtoMessage()               {}
func (*IndexRequest) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{26} }

type SearchResult struct {
	GameId string  `protobuf:"bytes,1,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
	Score  float64 `protobuf:"fixed64,2,opt,name=score,proto3" json:"score,omitempty"`
}

func (m *SearchResult) Reset()                    { *m = SearchResult{} }
func (m *SearchResult) String() string            { return proto.CompactTextString(m) }
func (*SearchResult) ProtoMessage()               {}
func (*SearchResult) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{27} }

type SearchRequest struct {
	Query string              `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	State RequestReleaseState `protobuf:"varint,2,opt,name=state,proto3,enum=apipb.RequestReleaseState" json:"state,omitempty"`
}

func (m *SearchRequest) Reset()                    { *m = SearchRequest{} }
func (m *SearchRequest) String() string            { return proto.CompactTextString(m) }
func (*SearchRequest) ProtoMessage()               {}
func (*SearchRequest) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{28} }

type SearchResponse struct {
	Type    int32           `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	Results []*SearchResult `protobuf:"bytes,2,rep,name=results" json:"results,omitempty"`
}

func (m *SearchResponse) Reset()                    { *m = SearchResponse{} }
func (m *SearchResponse) String() string            { return proto.CompactTextString(m) }
func (*SearchResponse) ProtoMessage()               {}
func (*SearchResponse) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{29} }

type Response struct {
	Type    int32  `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *Response) Reset()                    { *m = Response{} }
func (m *Response) String() string            { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()               {}
func (*Response) Descriptor() ([]byte, []int) { return fileDescriptorMessages, []int{30} }

func init() {
	proto.RegisterType((*Address)(nil), "apipb.Address")
	proto.RegisterType((*Profile)(nil), "apipb.Profile")
	proto.RegisterType((*ChildGameEntry)(nil), "apipb.ChildGameEntry")
	proto.RegisterType((*Child)(nil), "apipb.Child")
	proto.RegisterType((*Author)(nil), "apipb.Author")
	proto.RegisterType((*GameMetadata)(nil), "apipb.GameMetadata")
	proto.RegisterType((*GameManifest)(nil), "apipb.GameManifest")
	proto.RegisterType((*Game)(nil), "apipb.Game")
	proto.RegisterType((*GameRelease)(nil), "apipb.GameRelease")
	proto.RegisterType((*UploadToken)(nil), "apipb.UploadToken")
	proto.RegisterType((*GetProfileRequest)(nil), "apipb.GetProfileRequest")
	proto.RegisterType((*GetChildRequest)(nil), "apipb.GetChildRequest")
	proto.RegisterType((*GetChildrenFromProfileRequest)(nil), "apipb.GetChildrenFromProfileRequest")
	proto.RegisterType((*ChangeChildActivationRequest)(nil), "apipb.ChangeChildActivationRequest")
	proto.RegisterType((*GetChildrenFromProfileResponse)(nil), "apipb.GetChildrenFromProfileResponse")
	proto.RegisterType((*GetGameReleaseRequest)(nil), "apipb.GetGameReleaseRequest")
	proto.RegisterType((*SoundEnableRequest)(nil), "apipb.SoundEnableRequest")
	proto.RegisterType((*GameEntryRequest)(nil), "apipb.GameEntryRequest")
	proto.RegisterType((*PublishResponse)(nil), "apipb.PublishResponse")
	proto.RegisterType((*ValidateRequest)(nil), "apipb.ValidateRequest")
	proto.RegisterType((*GetGameRequest)(nil), "apipb.GetGameRequest")
	proto.RegisterType((*ListGamesRequest)(nil), "apipb.ListGamesRequest")
	proto.RegisterType((*ListItem)(nil), "apipb.ListItem")
	proto.RegisterType((*GetLatestVersionsRequest)(nil), "apipb.GetLatestVersionsRequest")
	proto.RegisterType((*GameAndVersion)(nil), "apipb.GameAndVersion")
	proto.RegisterType((*GameVersionsResponse)(nil), "apipb.GameVersionsResponse")
	proto.RegisterType((*IndexRequest)(nil), "apipb.IndexRequest")
	proto.RegisterType((*SearchResult)(nil), "apipb.SearchResult")
	proto.RegisterType((*SearchRequest)(nil), "apipb.SearchRequest")
	proto.RegisterType((*SearchResponse)(nil), "apipb.SearchResponse")
	proto.RegisterType((*Response)(nil), "apipb.Response")
	proto.RegisterEnum("apipb.Gender", Gender_name, Gender_value)
	proto.RegisterEnum("apipb.ReleaseState", ReleaseState_name, ReleaseState_value)
	proto.RegisterEnum("apipb.RequestReleaseState", RequestReleaseState_name, RequestReleaseState_value)
	proto.RegisterEnum("apipb.GameEntryRequest_RequestType", GameEntryRequest_RequestType_name, GameEntryRequest_RequestType_value)
	proto.RegisterEnum("apipb.ListGamesRequest_InnerState", ListGamesRequest_InnerState_name, ListGamesRequest_InnerState_value)
}
func (m *Address) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Address) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.StreetAddress) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.StreetAddress)))
		i += copy(data[i:], m.StreetAddress)
	}
	if len(m.City) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.City)))
		i += copy(data[i:], m.City)
	}
	if len(m.State) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.State)))
		i += copy(data[i:], m.State)
	}
	if len(m.ZipCode) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.ZipCode)))
		i += copy(data[i:], m.ZipCode)
	}
	if len(m.CountryCode) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.CountryCode)))
		i += copy(data[i:], m.CountryCode)
	}
	return i, nil
}

func (m *Profile) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Profile) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.Id)))
		i += copy(data[i:], m.Id)
	}
	if len(m.Email) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.Email)))
		i += copy(data[i:], m.Email)
	}
	if len(m.FirstName) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.FirstName)))
		i += copy(data[i:], m.FirstName)
	}
	if len(m.LastName) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.LastName)))
		i += copy(data[i:], m.LastName)
	}
	if len(m.Language) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.Language)))
		i += copy(data[i:], m.Language)
	}
	if len(m.MobilePhone) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.MobilePhone)))
		i += copy(data[i:], m.MobilePhone)
	}
	if m.Address != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintMessages(data, i, uint64(m.Address.Size()))
		n1, err := m.Address.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.CreatedAt != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintMessages(data, i, uint64(m.CreatedAt))
	}
	if m.LastUpdated != 0 {
		data[i] = 0x48
		i++
		i = encodeVarintMessages(data, i, uint64(m.LastUpdated))
	}
	return i, nil
}

func (m *ChildGameEntry) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ChildGameEntry) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.Id)))
		i += copy(data[i:], m.Id)
	}
	if m.Active {
		data[i] = 0x10
		i++
		if m.Active {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.DashboardIndex != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintMessages(data, i, uint64(m.DashboardIndex))
	}
	if m.Settings != nil {
		if len(m.Settings) > 0 {
			data[i] = 0x22
			i++
			i = encodeVarintMessages(data, i, uint64(len(m.Settings)))
			i += copy(data[i:], m.Settings)
		}
	}
	if m.AddedAt != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintMessages(data, i, uint64(m.AddedAt))
	}
	if m.ActivationChangedAt != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintMessages(data, i, uint64(m.ActivationChangedAt))
	}
	if m.UpdatedAt != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintMessages(data, i, uint64(m.UpdatedAt))
	}
	return i, nil
}

func (m *Child) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Child) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.Id)))
		i += copy(data[i:], m.Id)
	}
	if len(m.ParentId) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.ParentId)))
		i += copy(data[i:], m.ParentId)
	}
	if len(m.FirstName) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.FirstName)))
		i += copy(data[i:], m.FirstName)
	}
	if len(m.LastName) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.LastName)))
		i += copy(data[i:], m.LastName)
	}
	if m.BirthDay != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintMessages(data, i, uint64(m.BirthDay))
	}
	if m.Gender != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintMessages(data, i, uint64(m.Gender))
	}
	if len(m.Language) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.Language)))
		i += copy(data[i:], m.Language)
	}
	if len(m.Games) > 0 {
		for _, msg := range m.Games {
			data[i] = 0x4a
			i++
			i = encodeVarintMessages(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Active {
		data[i] = 0x50
		i++
		if m.Active {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.LoggedIn {
		data[i] = 0x58
		i++
		if m.LoggedIn {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.SoundsEnabled {
		data[i] = 0x60
		i++
		if m.SoundsEnabled {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.CreatedAt != 0 {
		data[i] = 0x78
		i++
		i = encodeVarintMessages(data, i, uint64(m.CreatedAt))
	}
	if m.LastUpdated != 0 {
		data[i] = 0x80
		i++
		data[i] = 0x1
		i++
		i = encodeVarintMessages(data, i, uint64(m.LastUpdated))
	}
	return i, nil
}

func (m *Author) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Author) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Email) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.Email)))
		i += copy(data[i:], m.Email)
	}
	return i, nil
}

func (m *GameMetadata) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GameMetadata) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Language) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.Language)))
		i += copy(data[i:], m.Language)
	}
	if len(m.VisibleName) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.VisibleName)))
		i += copy(data[i:], m.VisibleName)
	}
	if len(m.Summary) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.Summary)))
		i += copy(data[i:], m.Summary)
	}
	if len(m.Description) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.Description)))
		i += copy(data[i:], m.Description)
	}
	if len(m.Logo) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.Logo)))
		i += copy(data[i:], m.Logo)
	}
	if len(m.Icon) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.Icon)))
		i += copy(data[i:], m.Icon)
	}
	if len(m.Keywords) > 0 {
		for _, s := range m.Keywords {
			data[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Images) > 0 {
		for _, s := range m.Images {
			data[i] = 0x42
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.InfoSlug) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.InfoSlug)))
		i += copy(data[i:], m.InfoSlug)
	}
	if len(m.Assets) > 0 {
		for _, s := range m.Assets {
			data[i] = 0x52
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *GameManifest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GameManifest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UniqueName) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.UniqueName)))
		i += copy(data[i:], m.UniqueName)
	}
	if len(m.Licence) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.Licence)))
		i += copy(data[i:], m.Licence)
	}
	if len(m.Languages) > 0 {
		for _, s := range m.Languages {
			data[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Homepage) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.Homepage)))
		i += copy(data[i:], m.Homepage)
	}
	if len(m.Main) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.Main)))
		i += copy(data[i:], m.Main)
	}
	if len(m.Version) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.Version)))
		i += copy(data[i:], m.Version)
	}
	if len(m.Authors) > 0 {
		for _, msg := range m.Authors {
			data[i] = 0x3a
			i++
			i = encodeVarintMessages(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Repository) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.Repository)))
		i += copy(data[i:], m.Repository)
	}
	if len(m.Metadata) > 0 {
		for _, msg := range m.Metadata {
			data[i] = 0x6a
			i++
			i = encodeVarintMessages(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Exclude) > 0 {
		for _, s := range m.Exclude {
			data[i] = 0x72
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Settings) > 0 {
		data[i] = 0x7a
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.Settings)))
		i += copy(data[i:], m.Settings)
	}
	if len(m.KvPath) > 0 {
		data[i] = 0x82
		i++
		data[i] = 0x1
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.KvPath)))
		i += copy(data[i:], m.KvPath)
	}
	if len(m.DeveloperName) > 0 {
		data[i] = 0x8a
		i++
		data[i] = 0x1
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.DeveloperName)))
		i += copy(data[i:], m.DeveloperName)
	}
	if len(m.DefaultLanguage) > 0 {
		data[i] = 0x92
		i++
		data[i] = 0x1
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.DefaultLanguage)))
		i += copy(data[i:], m.DefaultLanguage)
	}
	return i, nil
}

func (m *Game) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Game) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.Id)))
		i += copy(data[i:], m.Id)
	}
	if len(m.UniqueName) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.UniqueName)))
		i += copy(data[i:], m.UniqueName)
	}
	if len(m.OwnerId) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.OwnerId)))
		i += copy(data[i:], m.OwnerId)
	}
	if len(m.ProductionVersion) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.ProductionVersion)))
		i += copy(data[i:], m.ProductionVersion)
	}
	if m.IsOnProduction {
		data[i] = 0x28
		i++
		if m.IsOnProduction {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.CreatedAt != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintMessages(data, i, uint64(m.CreatedAt))
	}
	if m.LastUpdated != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintMessages(data, i, uint64(m.LastUpdated))
	}
	return i, nil
}

func (m *GameRelease) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GameRelease) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ReleaseId) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.ReleaseId)))
		i += copy(data[i:], m.ReleaseId)
	}
	if len(m.GameId) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.GameId)))
		i += copy(data[i:], m.GameId)
	}
	if len(m.Version) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.Version)))
		i += copy(data[i:], m.Version)
	}
	if m.GameManifest != nil {
		data[i] = 0x22
		i++
		i = encodeVarintMessages(data, i, uint64(m.GameManifest.Size()))
		n2, err := m.GameManifest.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.ReleasedAt != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintMessages(data, i, uint64(m.ReleasedAt))
	}
	if len(m.ReleasedBy) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.ReleasedBy)))
		i += copy(data[i:], m.ReleasedBy)
	}
	if m.ReleaseState != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintMessages(data, i, uint64(m.ReleaseState))
	}
	if len(m.ValidatedBy) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.ValidatedBy)))
		i += copy(data[i:], m.ValidatedBy)
	}
	if m.ValidatedAt != 0 {
		data[i] = 0x48
		i++
		i = encodeVarintMessages(data, i, uint64(m.ValidatedAt))
	}
	if m.IntVersion != 0 {
		data[i] = 0x50
		i++
		i = encodeVarintMessages(data, i, uint64(m.IntVersion))
	}
	if len(m.Storage) > 0 {
		data[i] = 0x5a
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.Storage)))
		i += copy(data[i:], m.Storage)
	}
	if len(m.ArchiveFormat) > 0 {
		data[i] = 0x62
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.ArchiveFormat)))
		i += copy(data[i:], m.ArchiveFormat)
	}
	return i, nil
}

func (m *UploadToken) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *UploadToken) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Token) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.Token)))
		i += copy(data[i:], m.Token)
	}
	if m.ExpiresAt != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintMessages(data, i, uint64(m.ExpiresAt))
	}
	if len(m.UserId) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.UserId)))
		i += copy(data[i:], m.UserId)
	}
	if len(m.GameId) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.GameId)))
		i += copy(data[i:], m.GameId)
	}
	if len(m.NewVersion) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.NewVersion)))
		i += copy(data[i:], m.NewVersion)
	}
	if len(m.UploadTo) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.UploadTo)))
		i += copy(data[i:], m.UploadTo)
	}
	return i, nil
}

func (m *GetProfileRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetProfileRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.Id)))
		i += copy(data[i:], m.Id)
	}
	return i, nil
}

func (m *GetChildRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetChildRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChildId) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.ChildId)))
		i += copy(data[i:], m.ChildId)
	}
	return i, nil
}

func (m *GetChildrenFromProfileRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetChildrenFromProfileRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ProfileId) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.ProfileId)))
		i += copy(data[i:], m.ProfileId)
	}
	return i, nil
}

func (m *ChangeChildActivationRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ChangeChildActivationRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChildId) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.ChildId)))
		i += copy(data[i:], m.ChildId)
	}
	if m.Active {
		data[i] = 0x10
		i++
		if m.Active {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GetChildrenFromProfileResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetChildrenFromProfileResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Children) > 0 {
		for _, msg := range m.Children {
			data[i] = 0xa
			i++
			i = encodeVarintMessages(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GetGameReleaseRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetGameReleaseRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GameId) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.GameId)))
		i += copy(data[i:], m.GameId)
	}
	if len(m.Version) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.Version)))
		i += copy(data[i:], m.Version)
	}
	if m.State != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintMessages(data, i, uint64(m.State))
	}
	return i, nil
}

func (m *SoundEnableRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SoundEnableRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChildId) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.ChildId)))
		i += copy(data[i:], m.ChildId)
	}
	if len(m.ProfileId) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.ProfileId)))
		i += copy(data[i:], m.ProfileId)
	}
	if m.Enable {
		data[i] = 0x18
		i++
		if m.Enable {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GameEntryRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GameEntryRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChildId) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.ChildId)))
		i += copy(data[i:], m.ChildId)
	}
	if len(m.GameId) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.GameId)))
		i += copy(data[i:], m.GameId)
	}
	if m.Type != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintMessages(data, i, uint64(m.Type))
	}
	if m.Settings != nil {
		if len(m.Settings) > 0 {
			data[i] = 0x22
			i++
			i = encodeVarintMessages(data, i, uint64(len(m.Settings)))
			i += copy(data[i:], m.Settings)
		}
	}
	if m.Index != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintMessages(data, i, uint64(m.Index))
	}
	return i, nil
}

func (m *PublishResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PublishResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintMessages(data, i, uint64(m.Type))
	}
	if len(m.Message) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.Message)))
		i += copy(data[i:], m.Message)
	}
	if m.Token != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintMessages(data, i, uint64(m.Token.Size()))
		n3, err := m.Token.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *ValidateRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ValidateRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GameId) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.GameId)))
		i += copy(data[i:], m.GameId)
	}
	if len(m.GameVersion) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.GameVersion)))
		i += copy(data[i:], m.GameVersion)
	}
	if m.NewState != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintMessages(data, i, uint64(m.NewState))
	}
	return i, nil
}

func (m *GetGameRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetGameRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UniqueName) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.UniqueName)))
		i += copy(data[i:], m.UniqueName)
	}
	if len(m.GameId) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.GameId)))
		i += copy(data[i:], m.GameId)
	}
	return i, nil
}

func (m *ListGamesRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ListGamesRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ReleaseState != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintMessages(data, i, uint64(m.ReleaseState))
	}
	if m.Limit != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintMessages(data, i, uint64(m.Limit))
	}
	if m.Offset != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintMessages(data, i, uint64(m.Offset))
	}
	return i, nil
}

func (m *ListItem) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ListItem) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GameId) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.GameId)))
		i += copy(data[i:], m.GameId)
	}
	if len(m.UniqueName) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.UniqueName)))
		i += copy(data[i:], m.UniqueName)
	}
	if len(m.LatestVersion) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.LatestVersion)))
		i += copy(data[i:], m.LatestVersion)
	}
	if m.LatestState != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintMessages(data, i, uint64(m.LatestState))
	}
	if len(m.ProductionVersion) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.ProductionVersion)))
		i += copy(data[i:], m.ProductionVersion)
	}
	if len(m.Storage) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.Storage)))
		i += copy(data[i:], m.Storage)
	}
	if len(m.ArchiveFormat) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.ArchiveFormat)))
		i += copy(data[i:], m.ArchiveFormat)
	}
	return i, nil
}

func (m *GetLatestVersionsRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetLatestVersionsRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintMessages(data, i, uint64(m.State))
	}
	if len(m.GameIds) > 0 {
		for _, s := range m.GameIds {
			data[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *GameAndVersion) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GameAndVersion) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GameId) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.GameId)))
		i += copy(data[i:], m.GameId)
	}
	if len(m.Version) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.Version)))
		i += copy(data[i:], m.Version)
	}
	if len(m.TarballUrl) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.TarballUrl)))
		i += copy(data[i:], m.TarballUrl)
	}
	return i, nil
}

func (m *GameVersionsResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GameVersionsResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Results) > 0 {
		for _, msg := range m.Results {
			data[i] = 0xa
			i++
			i = encodeVarintMessages(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *IndexRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *IndexRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *SearchResult) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SearchResult) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GameId) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.GameId)))
		i += copy(data[i:], m.GameId)
	}
	if m.Score != 0 {
		data[i] = 0x11
		i++
		i = encodeFixed64Messages(data, i, uint64(math.Float64bits(float64(m.Score))))
	}
	return i, nil
}

func (m *SearchRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SearchRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Query) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.Query)))
		i += copy(data[i:], m.Query)
	}
	if m.State != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintMessages(data, i, uint64(m.State))
	}
	return i, nil
}

func (m *SearchResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SearchResponse) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintMessages(data, i, uint64(m.Type))
	}
	if len(m.Results) > 0 {
		for _, msg := range m.Results {
			data[i] = 0x12
			i++
			i = encodeVarintMessages(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Response) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Response) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintMessages(data, i, uint64(m.Type))
	}
	if len(m.Message) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintMessages(data, i, uint64(len(m.Message)))
		i += copy(data[i:], m.Message)
	}
	return i, nil
}

func encodeFixed64Messages(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Messages(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintMessages(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *Address) Size() (n int) {
	var l int
	_ = l
	l = len(m.StreetAddress)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.City)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.ZipCode)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.CountryCode)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *Profile) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.FirstName)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.LastName)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.MobilePhone)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Address != nil {
		l = m.Address.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.CreatedAt != 0 {
		n += 1 + sovMessages(uint64(m.CreatedAt))
	}
	if m.LastUpdated != 0 {
		n += 1 + sovMessages(uint64(m.LastUpdated))
	}
	return n
}

func (m *ChildGameEntry) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Active {
		n += 2
	}
	if m.DashboardIndex != 0 {
		n += 1 + sovMessages(uint64(m.DashboardIndex))
	}
	if m.Settings != nil {
		l = len(m.Settings)
		if l > 0 {
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if m.AddedAt != 0 {
		n += 1 + sovMessages(uint64(m.AddedAt))
	}
	if m.ActivationChangedAt != 0 {
		n += 1 + sovMessages(uint64(m.ActivationChangedAt))
	}
	if m.UpdatedAt != 0 {
		n += 1 + sovMessages(uint64(m.UpdatedAt))
	}
	return n
}

func (m *Child) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.ParentId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.FirstName)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.LastName)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.BirthDay != 0 {
		n += 1 + sovMessages(uint64(m.BirthDay))
	}
	if m.Gender != 0 {
		n += 1 + sovMessages(uint64(m.Gender))
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Games) > 0 {
		for _, e := range m.Games {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if m.Active {
		n += 2
	}
	if m.LoggedIn {
		n += 2
	}
	if m.SoundsEnabled {
		n += 2
	}
	if m.CreatedAt != 0 {
		n += 1 + sovMessages(uint64(m.CreatedAt))
	}
	if m.LastUpdated != 0 {
		n += 2 + sovMessages(uint64(m.LastUpdated))
	}
	return n
}

func (m *Author) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *GameMetadata) Size() (n int) {
	var l int
	_ = l
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.VisibleName)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Summary)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Logo)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Icon)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Keywords) > 0 {
		for _, s := range m.Keywords {
			l = len(s)
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if len(m.Images) > 0 {
		for _, s := range m.Images {
			l = len(s)
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	l = len(m.InfoSlug)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Assets) > 0 {
		for _, s := range m.Assets {
			l = len(s)
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *GameManifest) Size() (n int) {
	var l int
	_ = l
	l = len(m.UniqueName)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Licence)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Languages) > 0 {
		for _, s := range m.Languages {
			l = len(s)
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	l = len(m.Homepage)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Main)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Authors) > 0 {
		for _, e := range m.Authors {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	l = len(m.Repository)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if len(m.Metadata) > 0 {
		for _, e := range m.Metadata {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if len(m.Exclude) > 0 {
		for _, s := range m.Exclude {
			l = len(s)
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	l = len(m.Settings)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.KvPath)
	if l > 0 {
		n += 2 + l + sovMessages(uint64(l))
	}
	l = len(m.DeveloperName)
	if l > 0 {
		n += 2 + l + sovMessages(uint64(l))
	}
	l = len(m.DefaultLanguage)
	if l > 0 {
		n += 2 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *Game) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.UniqueName)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.OwnerId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.ProductionVersion)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.IsOnProduction {
		n += 2
	}
	if m.CreatedAt != 0 {
		n += 1 + sovMessages(uint64(m.CreatedAt))
	}
	if m.LastUpdated != 0 {
		n += 1 + sovMessages(uint64(m.LastUpdated))
	}
	return n
}

func (m *GameRelease) Size() (n int) {
	var l int
	_ = l
	l = len(m.ReleaseId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.GameId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.GameManifest != nil {
		l = m.GameManifest.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.ReleasedAt != 0 {
		n += 1 + sovMessages(uint64(m.ReleasedAt))
	}
	l = len(m.ReleasedBy)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.ReleaseState != 0 {
		n += 1 + sovMessages(uint64(m.ReleaseState))
	}
	l = len(m.ValidatedBy)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.ValidatedAt != 0 {
		n += 1 + sovMessages(uint64(m.ValidatedAt))
	}
	if m.IntVersion != 0 {
		n += 1 + sovMessages(uint64(m.IntVersion))
	}
	l = len(m.Storage)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.ArchiveFormat)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *UploadToken) Size() (n int) {
	var l int
	_ = l
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.ExpiresAt != 0 {
		n += 1 + sovMessages(uint64(m.ExpiresAt))
	}
	l = len(m.UserId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.GameId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.NewVersion)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.UploadTo)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *GetProfileRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *GetChildRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChildId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *GetChildrenFromProfileRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.ProfileId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *ChangeChildActivationRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChildId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Active {
		n += 2
	}
	return n
}

func (m *GetChildrenFromProfileResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Children) > 0 {
		for _, e := range m.Children {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *GetGameReleaseRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.GameId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovMessages(uint64(m.State))
	}
	return n
}

func (m *SoundEnableRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChildId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.ProfileId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Enable {
		n += 2
	}
	return n
}

func (m *GameEntryRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChildId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.GameId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovMessages(uint64(m.Type))
	}
	if m.Settings != nil {
		l = len(m.Settings)
		if l > 0 {
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	if m.Index != 0 {
		n += 1 + sovMessages(uint64(m.Index))
	}
	return n
}

func (m *PublishResponse) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovMessages(uint64(m.Type))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Token != nil {
		l = m.Token.Size()
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *ValidateRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.GameId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.GameVersion)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.NewState != 0 {
		n += 1 + sovMessages(uint64(m.NewState))
	}
	return n
}

func (m *GetGameRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.UniqueName)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.GameId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *ListGamesRequest) Size() (n int) {
	var l int
	_ = l
	if m.ReleaseState != 0 {
		n += 1 + sovMessages(uint64(m.ReleaseState))
	}
	if m.Limit != 0 {
		n += 1 + sovMessages(uint64(m.Limit))
	}
	if m.Offset != 0 {
		n += 1 + sovMessages(uint64(m.Offset))
	}
	return n
}

func (m *ListItem) Size() (n int) {
	var l int
	_ = l
	l = len(m.GameId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.UniqueName)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.LatestVersion)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.LatestState != 0 {
		n += 1 + sovMessages(uint64(m.LatestState))
	}
	l = len(m.ProductionVersion)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Storage)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.ArchiveFormat)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *GetLatestVersionsRequest) Size() (n int) {
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovMessages(uint64(m.State))
	}
	if len(m.GameIds) > 0 {
		for _, s := range m.GameIds {
			l = len(s)
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *GameAndVersion) Size() (n int) {
	var l int
	_ = l
	l = len(m.GameId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	l = len(m.TarballUrl)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func (m *GameVersionsResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Results) > 0 {
		for _, e := range m.Results {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *IndexRequest) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *SearchResult) Size() (n int) {
	var l int
	_ = l
	l = len(m.GameId)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.Score != 0 {
		n += 9
	}
	return n
}

func (m *SearchRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovMessages(uint64(m.State))
	}
	return n
}

func (m *SearchResponse) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovMessages(uint64(m.Type))
	}
	if len(m.Results) > 0 {
		for _, e := range m.Results {
			l = e.Size()
			n += 1 + l + sovMessages(uint64(l))
		}
	}
	return n
}

func (m *Response) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovMessages(uint64(m.Type))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovMessages(uint64(l))
	}
	return n
}

func sovMessages(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMessages(x uint64) (n int) {
	return sovMessages(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Address) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Address: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Address: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreetAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StreetAddress = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field City", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.City = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZipCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ZipCode = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountryCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CountryCode = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Profile) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Profile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Profile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = gopkg_in_mgo_v2_bson.ObjectId(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MobilePhone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MobilePhone = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Address == nil {
				m.Address = &Address{}
			}
			if err := m.Address.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CreatedAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdated", wireType)
			}
			m.LastUpdated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LastUpdated |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChildGameEntry) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChildGameEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChildGameEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = gopkg_in_mgo_v2_bson.ObjectId(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DashboardIndex", wireType)
			}
			m.DashboardIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DashboardIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Settings", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Settings = append(m.Settings[:0], data[iNdEx:postIndex]...)
			if m.Settings == nil {
				m.Settings = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddedAt", wireType)
			}
			m.AddedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.AddedAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivationChangedAt", wireType)
			}
			m.ActivationChangedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ActivationChangedAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			m.UpdatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UpdatedAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Child) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Child: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Child: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = gopkg_in_mgo_v2_bson.ObjectId(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentId = gopkg_in_mgo_v2_bson.ObjectId(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BirthDay", wireType)
			}
			m.BirthDay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.BirthDay |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gender", wireType)
			}
			m.Gender = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Gender |= (Gender(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Games", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Games = append(m.Games, &ChildGameEntry{})
			if err := m.Games[len(m.Games)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoggedIn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LoggedIn = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoundsEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SoundsEnabled = bool(v != 0)
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CreatedAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdated", wireType)
			}
			m.LastUpdated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LastUpdated |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Author) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Author: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Author: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameMetadata) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VisibleName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VisibleName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summary", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Summary = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Logo = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Icon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Icon = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keywords", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keywords = append(m.Keywords, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Images", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Images = append(m.Images, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfoSlug", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InfoSlug = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assets", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Assets = append(m.Assets, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameManifest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameManifest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameManifest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Licence", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Licence = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Languages", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Languages = append(m.Languages, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Homepage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Homepage = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Main", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Main = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authors = append(m.Authors, &Author{})
			if err := m.Authors[len(m.Authors)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repository", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Repository = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = append(m.Metadata, &GameMetadata{})
			if err := m.Metadata[len(m.Metadata)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exclude", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exclude = append(m.Exclude, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Settings", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Settings = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KvPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KvPath = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeveloperName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeveloperName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultLanguage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultLanguage = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Game) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Game: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Game: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = gopkg_in_mgo_v2_bson.ObjectId(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnerId = gopkg_in_mgo_v2_bson.ObjectId(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductionVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductionVersion = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOnProduction", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsOnProduction = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CreatedAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdated", wireType)
			}
			m.LastUpdated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LastUpdated |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameRelease) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameRelease: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameRelease: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReleaseId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReleaseId = gopkg_in_mgo_v2_bson.ObjectId(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameId = gopkg_in_mgo_v2_bson.ObjectId(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameManifest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GameManifest == nil {
				m.GameManifest = &GameManifest{}
			}
			if err := m.GameManifest.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReleasedAt", wireType)
			}
			m.ReleasedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ReleasedAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReleasedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReleasedBy = gopkg_in_mgo_v2_bson.ObjectId(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReleaseState", wireType)
			}
			m.ReleaseState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ReleaseState |= (ReleaseState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatedBy = gopkg_in_mgo_v2_bson.ObjectId(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatedAt", wireType)
			}
			m.ValidatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ValidatedAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntVersion", wireType)
			}
			m.IntVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.IntVersion |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Storage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Storage = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArchiveFormat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ArchiveFormat = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadToken) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadToken: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadToken: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresAt", wireType)
			}
			m.ExpiresAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ExpiresAt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserId = gopkg_in_mgo_v2_bson.ObjectId(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameId = gopkg_in_mgo_v2_bson.ObjectId(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewVersion = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadTo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UploadTo = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetProfileRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetProfileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetProfileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetChildRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetChildRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetChildRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChildId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetChildrenFromProfileRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetChildrenFromProfileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetChildrenFromProfileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProfileId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangeChildActivationRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangeChildActivationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangeChildActivationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChildId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetChildrenFromProfileResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetChildrenFromProfileResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetChildrenFromProfileResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Children = append(m.Children, &Child{})
			if err := m.Children[len(m.Children)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetGameReleaseRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetGameReleaseRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetGameReleaseRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.State |= (RequestReleaseState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SoundEnableRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SoundEnableRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SoundEnableRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChildId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProfileId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProfileId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameEntryRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameEntryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameEntryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChildId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Type |= (GameEntryRequest_RequestType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Settings", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Settings = append(m.Settings[:0], data[iNdEx:postIndex]...)
			if m.Settings == nil {
				m.Settings = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Index |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublishResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublishResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublishResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Token == nil {
				m.Token = &UploadToken{}
			}
			if err := m.Token.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidateRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameVersion = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewState", wireType)
			}
			m.NewState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.NewState |= (ReleaseState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetGameRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetGameRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetGameRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListGamesRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListGamesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListGamesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReleaseState", wireType)
			}
			m.ReleaseState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ReleaseState |= (ListGamesRequest_InnerState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Limit |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Offset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListItem) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UniqueName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LatestVersion = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestState", wireType)
			}
			m.LatestState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LatestState |= (ReleaseState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProductionVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProductionVersion = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Storage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Storage = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArchiveFormat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ArchiveFormat = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLatestVersionsRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLatestVersionsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLatestVersionsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.State |= (RequestReleaseState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameIds = append(m.GameIds, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameAndVersion) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameAndVersion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameAndVersion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TarballUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TarballUrl = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GameVersionsResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GameVersionsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GameVersionsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Results = append(m.Results, &GameAndVersion{})
			if err := m.Results[len(m.Results)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchResult) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Score = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.State |= (RequestReleaseState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Results = append(m.Results, &SearchResult{})
			if err := m.Results[len(m.Results)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessages
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessages(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessages
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMessages(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMessages
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessages
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMessages
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMessages
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMessages(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMessages = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMessages   = fmt.Errorf("proto: integer overflow")
)

var fileDescriptorMessages = []byte{
	// 2761 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xc4, 0x5a, 0x4b, 0x6f, 0xdb, 0xd8,
	0x15, 0xb6, 0xde, 0xd2, 0x91, 0x2c, 0x2b, 0x4c, 0x3c, 0xd1, 0x78, 0x12, 0x3b, 0xc3, 0x20, 0xd3,
	0x69, 0x9a, 0x38, 0x45, 0xd2, 0x99, 0x4c, 0x33, 0x9d, 0x01, 0x24, 0x4b, 0x31, 0x94, 0xfa, 0x55,
	0xca, 0x76, 0xda, 0x41, 0x0b, 0x95, 0x12, 0x29, 0x99, 0x0d, 0x45, 0xaa, 0x24, 0xe5, 0xc4, 0x45,
	0x81, 0xf6, 0x27, 0x0c, 0xd0, 0x7f, 0xd0, 0x45, 0xf7, 0xdd, 0xb4, 0x7f, 0x21, 0x40, 0x37, 0x5d,
	0x75, 0xd1, 0xc5, 0xa0, 0x8f, 0x5f, 0xd0, 0xae, 0xba, 0x2a, 0x7a, 0xee, 0x8b, 0xbc, 0x97, 0xb1,
	0x31, 0x4a, 0x66, 0x80, 0x2e, 0x0c, 0x90, 0xe7, 0x75, 0xef, 0x3d, 0xe7, 0x3b, 0x8f, 0x4b, 0x19,
	0xea, 0x53, 0x3b, 0x0c, 0xcd, 0x89, 0x1d, 0x6e, 0xce, 0x02, 0x3f, 0xf2, 0xb5, 0x82, 0x39, 0x73,
	0x66, 0xc3, 0xb5, 0x2b, 0x13, 0x7f, 0xe2, 0x53, 0xca, 0x3d, 0xf2, 0xc4, 0x98, 0xfa, 0x1f, 0xb2,
	0x50, 0x6a, 0x59, 0x56, 0x80, 0x2a, 0xda, 0x13, 0xa8, 0x87, 0x51, 0x60, 0xdb, 0xd1, 0xc0, 0x64,
	0x94, 0x66, 0xe6, 0x46, 0xe6, 0xfd, 0x4a, 0xfb, 0xe6, 0xbf, 0xbf, 0xd8, 0xd8, 0x18, 0x86, 0xbe,
	0xf7, 0x48, 0x57, 0xf9, 0x77, 0xfc, 0xa9, 0x13, 0xd9, 0xd3, 0x59, 0x74, 0xa6, 0x1b, 0xcb, 0x8c,
	0x25, 0x6c, 0xdd, 0x85, 0xfc, 0xc8, 0x89, 0xce, 0x9a, 0x59, 0x6a, 0xe1, 0x6d, 0xb4, 0xb0, 0xca,
	0x2c, 0x10, 0xaa, 0xac, 0x47, 0xc5, 0xb4, 0x6f, 0x43, 0x21, 0x8c, 0xcc, 0xc8, 0x6e, 0xe6, 0xa8,
	0xfc, 0x1a, 0xca, 0xbf, 0x25, 0x56, 0x44, 0xb2, 0xac, 0xc0, 0x04, 0xb5, 0x8f, 0xa0, 0xfc, 0x0b,
	0x67, 0x36, 0x18, 0xf9, 0x96, 0xdd, 0xcc, 0x53, 0xa5, 0xeb, 0xa8, 0xf4, 0x36, 0x53, 0x12, 0x1c,
	0x59, 0xaf, 0x84, 0xc4, 0x2d, 0xa4, 0x69, 0x1d, 0xa8, 0x8d, 0xfc, 0xb9, 0x17, 0x05, 0x67, 0x4c,
	0xbb, 0x40, 0xb5, 0xdf, 0x45, 0xed, 0xeb, 0x7c, 0x8b, 0x12, 0x57, 0xb6, 0x50, 0xe5, 0x0c, 0x62,
	0x45, 0xff, 0x4b, 0x1e, 0x4a, 0x07, 0x81, 0x3f, 0x76, 0x5c, 0x5b, 0xdb, 0x85, 0xac, 0x63, 0x71,
	0x67, 0x7d, 0xf2, 0xf2, 0x8b, 0x8d, 0xa5, 0xbf, 0xa2, 0x2d, 0x74, 0xf6, 0xb3, 0xc9, 0xa6, 0xe3,
	0xdd, 0x9b, 0xa2, 0xb3, 0x4f, 0xef, 0xdf, 0x23, 0xb6, 0x37, 0xf7, 0x87, 0x3f, 0xb3, 0x47, 0x51,
	0xcf, 0xc2, 0xc5, 0xae, 0xb0, 0xc5, 0x06, 0x8e, 0x25, 0xaf, 0x81, 0x86, 0x88, 0x33, 0xec, 0xa9,
	0xe9, 0xb8, 0xdc, 0x79, 0x92, 0x33, 0x28, 0x59, 0x71, 0x06, 0xa5, 0x68, 0x9f, 0x02, 0x8c, 0x9d,
	0x20, 0x8c, 0x06, 0x9e, 0x39, 0x15, 0x3e, 0xdc, 0x40, 0xb5, 0x77, 0x98, 0x5a, 0xc2, 0x93, 0x75,
	0x2b, 0x94, 0xbc, 0x87, 0x54, 0xed, 0x63, 0xa8, 0xb8, 0xa6, 0x50, 0x67, 0xde, 0x5c, 0x47, 0xf5,
	0x35, 0xa6, 0x1e, 0xb3, 0x64, 0xed, 0x32, 0xa1, 0x52, 0xe5, 0xef, 0x02, 0x3e, 0x7b, 0x93, 0x39,
	0x42, 0x8e, 0xfb, 0x52, 0x8a, 0x84, 0xe0, 0xa4, 0x54, 0x19, 0x91, 0x84, 0x62, 0xea, 0x0f, 0xd1,
	0x85, 0x83, 0xd9, 0x89, 0xef, 0xd9, 0xcd, 0x62, 0x3a, 0x14, 0x32, 0x57, 0x09, 0x05, 0x63, 0x1c,
	0x10, 0xba, 0xf6, 0x18, 0x4a, 0x02, 0xb0, 0x25, 0x34, 0x50, 0xbd, 0x5f, 0xdf, 0xa4, 0x90, 0xdf,
	0xe4, 0x60, 0x6c, 0x5f, 0x43, 0x83, 0x4d, 0x66, 0xf0, 0x1c, 0xe4, 0x0a, 0x65, 0xe2, 0xc5, 0x51,
	0x60, 0x23, 0xb8, 0xac, 0x81, 0x19, 0x35, 0xcb, 0x68, 0x2a, 0x27, 0x7b, 0x31, 0xe1, 0x29, 0x5e,
	0xe4, 0xe4, 0x56, 0x44, 0x4e, 0x43, 0x5d, 0x35, 0x9f, 0x59, 0x84, 0xd2, 0xac, 0x50, 0x0b, 0xd2,
	0x69, 0x64, 0xae, 0x72, 0x1a, 0xc2, 0x38, 0x62, 0x74, 0xfd, 0xf7, 0x39, 0xa8, 0x6f, 0x9d, 0x38,
	0xae, 0xb5, 0x8d, 0xce, 0xed, 0x12, 0xbc, 0x69, 0x6d, 0x09, 0x5f, 0xf7, 0x17, 0xc5, 0x57, 0x85,
	0xad, 0xe9, 0x58, 0x0c, 0x54, 0xdf, 0x84, 0xa2, 0x39, 0x8a, 0x9c, 0x53, 0x9b, 0xa2, 0xaa, 0xdc,
	0xbe, 0x84, 0x22, 0xcb, 0xdc, 0x27, 0x94, 0xae, 0x1b, 0x5c, 0x40, 0xdb, 0x82, 0x15, 0xcb, 0x0c,
	0x4f, 0x86, 0xbe, 0x19, 0x58, 0x03, 0xc7, 0xb3, 0xec, 0x17, 0x14, 0x52, 0x05, 0x19, 0x89, 0x29,
	0x01, 0xdd, 0xa8, 0xc7, 0x94, 0x1e, 0x21, 0x68, 0xf7, 0xa0, 0x1c, 0xda, 0x51, 0xe4, 0x78, 0x93,
	0x90, 0x22, 0xaa, 0xd6, 0xbe, 0x8c, 0xda, 0x2b, 0x3c, 0xa9, 0x39, 0x07, 0xb1, 0x20, 0x1e, 0xb5,
	0x4d, 0x28, 0x63, 0x20, 0x98, 0xef, 0x0b, 0xd4, 0x73, 0x92, 0x82, 0xe0, 0xb0, 0x68, 0x51, 0x6f,
	0x1f, 0xc2, 0x2a, 0xdd, 0xaf, 0x19, 0x39, 0xbe, 0x37, 0x18, 0x9d, 0x20, 0xa6, 0x98, 0x72, 0x91,
	0x2a, 0xdf, 0x40, 0xe5, 0x6b, 0xd2, 0xf9, 0xd2, 0x62, 0xba, 0x71, 0x39, 0xa1, 0x6f, 0x31, 0x32,
	0x5a, 0xfd, 0x0e, 0x00, 0x0f, 0x10, 0x31, 0x55, 0xa2, 0xa6, 0x56, 0xd1, 0xd4, 0x25, 0x66, 0x2a,
	0xe1, 0x61, 0xe4, 0xf9, 0x4b, 0x2b, 0xd2, 0xff, 0x5b, 0x84, 0x02, 0x8d, 0xd9, 0xd7, 0x5d, 0x0a,
	0x7e, 0x0a, 0x95, 0x99, 0x19, 0xd8, 0x5e, 0x84, 0x3c, 0x5e, 0x0e, 0xb6, 0x16, 0xb5, 0xca, 0xb3,
	0x37, 0xd6, 0x57, 0x52, 0x90, 0x51, 0x7b, 0xd6, 0xff, 0xb7, 0x74, 0xa0, 0xf2, 0xd0, 0x09, 0xa2,
	0x93, 0x81, 0x65, 0x9e, 0xf1, 0xa0, 0x4b, 0xca, 0x31, 0x4b, 0x51, 0xa6, 0xd4, 0x8e, 0x49, 0xb2,
	0xa2, 0x38, 0xb1, 0x11, 0x6b, 0x01, 0x0d, 0x53, 0xfd, 0xfe, 0x32, 0xcf, 0xfa, 0x6d, 0x4a, 0x6c,
	0xbf, 0x83, 0x86, 0xae, 0x32, 0x43, 0x4c, 0x4c, 0xb6, 0xc2, 0x35, 0x95, 0xda, 0x55, 0x7e, 0xbd,
	0xda, 0xb5, 0x0d, 0x85, 0x09, 0x9e, 0x21, 0xc4, 0x34, 0xcf, 0x61, 0xcd, 0x59, 0xe5, 0xab, 0xab,
	0xa9, 0x2b, 0xa7, 0x0c, 0x95, 0x56, 0x8a, 0x37, 0xa5, 0x68, 0x0f, 0xe2, 0xcc, 0x04, 0x9a, 0x99,
	0xd2, 0xc6, 0x19, 0x5d, 0xd9, 0x38, 0xcf, 0x51, 0xe2, 0x76, 0x7f, 0x42, 0xa0, 0xec, 0x78, 0xcd,
	0x2a, 0xd5, 0x93, 0xdd, 0x2e, 0x58, 0xea, 0xd6, 0x29, 0xb5, 0xe7, 0xd1, 0x46, 0x8f, 0xad, 0xcc,
	0x0a, 0x07, 0xb6, 0x67, 0x0e, 0x5d, 0x2c, 0x55, 0x35, 0x6a, 0x41, 0x6e, 0xf4, 0x0a, 0x5f, 0x6d,
	0xf4, 0x94, 0xd5, 0x65, 0x9c, 0x54, 0xd1, 0x5c, 0xf9, 0xca, 0x45, 0xb3, 0xf1, 0x46, 0x45, 0xd3,
	0x81, 0x62, 0x6b, 0x1e, 0x9d, 0xf8, 0x01, 0x19, 0x3c, 0x28, 0x14, 0x33, 0xe9, 0xc1, 0x23, 0x8d,
	0x42, 0x2a, 0xf6, 0xfa, 0xbd, 0x56, 0xff, 0x53, 0x1e, 0x6a, 0x24, 0xbe, 0xbb, 0x76, 0x64, 0xe2,
	0xe2, 0xa6, 0x82, 0xa1, 0xcc, 0x6b, 0xf7, 0xbf, 0x53, 0x27, 0x74, 0xd0, 0x91, 0x2c, 0x7f, 0xb2,
	0xe9, 0xfe, 0x27, 0x73, 0x95, 0xc3, 0x73, 0x06, 0xcd, 0xa2, 0x0f, 0xa1, 0x14, 0xce, 0xa7, 0x53,
	0x33, 0x38, 0xe3, 0xf9, 0x2b, 0xf5, 0x3b, 0xce, 0x50, 0xfa, 0x1d, 0xa7, 0x61, 0x02, 0x55, 0x2d,
	0x3b, 0x1c, 0x05, 0xce, 0x8c, 0xd4, 0x40, 0x9e, 0xbc, 0x52, 0xdd, 0x94, 0x98, 0xca, 0xda, 0x12,
	0x9d, 0xb8, 0x1b, 0x61, 0xe5, 0xf3, 0xc6, 0x2f, 0xb9, 0x9b, 0x50, 0x15, 0x77, 0x13, 0x02, 0x11,
	0x77, 0x46, 0xb8, 0x56, 0x31, 0x2d, 0x4e, 0xa8, 0x8a, 0x38, 0x21, 0x10, 0xd7, 0x3e, 0xb3, 0xcf,
	0x9e, 0xfb, 0x81, 0x45, 0x5a, 0x7b, 0x4e, 0x75, 0xad, 0xe0, 0x28, 0xae, 0x15, 0x44, 0x92, 0x55,
	0xce, 0x94, 0x4c, 0xc1, 0x98, 0xd7, 0x44, 0x51, 0xca, 0x2a, 0x46, 0x57, 0xb2, 0x8a, 0x91, 0x48,
	0x56, 0x39, 0xde, 0xd8, 0x1f, 0x84, 0xee, 0x7c, 0x42, 0xdb, 0xb7, 0x52, 0xcc, 0x62, 0x96, 0xb2,
	0x22, 0xa1, 0xf6, 0x91, 0x48, 0xf3, 0x38, 0xc4, 0x76, 0x16, 0x62, 0x1e, 0xa7, 0x56, 0x64, 0x74,
	0x35, 0x8f, 0x29, 0x49, 0xff, 0xbc, 0xc4, 0xd1, 0x64, 0x7a, 0xce, 0xd8, 0x0e, 0x23, 0xad, 0x0f,
	0xd5, 0xb9, 0xe7, 0xfc, 0x7c, 0xce, 0x11, 0xc1, 0x9b, 0x3e, 0x9a, 0xda, 0xe4, 0x1d, 0x28, 0x61,
	0x4a, 0xf6, 0x6e, 0x8c, 0x5c, 0xe7, 0x91, 0x7e, 0x44, 0x79, 0x37, 0x08, 0x28, 0x74, 0x03, 0x98,
	0x24, 0x45, 0x48, 0x07, 0x4a, 0xae, 0x33, 0xb2, 0xbd, 0x91, 0x80, 0xd8, 0x6d, 0x34, 0xf8, 0x1e,
	0x0f, 0x14, 0x63, 0xbc, 0x62, 0x6c, 0x87, 0xd1, 0x11, 0x2f, 0x5c, 0x42, 0xfb, 0x1e, 0x29, 0xf5,
	0x0c, 0xb9, 0x21, 0x22, 0x2d, 0x97, 0x2e, 0xf5, 0x9c, 0xa5, 0x24, 0x7a, 0x4c, 0x25, 0xb1, 0x3c,
	0xf1, 0xa7, 0xf6, 0x8c, 0xa4, 0xc9, 0x2b, 0x03, 0xbb, 0xe0, 0x28, 0x9e, 0x15, 0x44, 0x1c, 0x0d,
	0xf2, 0x98, 0x7a, 0x1e, 0x07, 0x99, 0x94, 0xa3, 0x84, 0xca, 0xb7, 0xbb, 0x4b, 0x1e, 0x0d, 0x2a,
	0xa7, 0x3d, 0x82, 0xd2, 0xa9, 0x1d, 0x84, 0x4e, 0x0c, 0x34, 0x09, 0xd4, 0x9c, 0xc1, 0xb5, 0x8e,
	0xf9, 0x9b, 0x21, 0x14, 0x10, 0x02, 0x25, 0x93, 0x56, 0x12, 0x86, 0xb8, 0x6a, 0xdc, 0x56, 0x58,
	0x7d, 0x69, 0x6b, 0x68, 0xaa, 0xce, 0xa3, 0xca, 0xe4, 0xc8, 0x4c, 0xc2, 0x9e, 0xb4, 0x0f, 0x00,
	0x02, 0x7b, 0xe6, 0x87, 0x4e, 0xe4, 0x63, 0x32, 0xb2, 0x86, 0x22, 0x4d, 0x0f, 0x09, 0x0f, 0xc3,
	0x93, 0xbc, 0x68, 0x7b, 0x50, 0x9e, 0xf2, 0x6a, 0xd2, 0x5c, 0xa6, 0x8b, 0x5e, 0x16, 0xbd, 0x4c,
	0x2a, 0x34, 0xb2, 0xbf, 0x84, 0xb8, 0xe2, 0x2f, 0x41, 0xd4, 0xee, 0x40, 0xc9, 0x7e, 0x31, 0x72,
	0xe7, 0x78, 0xb9, 0xa9, 0xd3, 0x30, 0x49, 0x9b, 0xe6, 0x0c, 0xdc, 0x34, 0x7f, 0x22, 0x81, 0x89,
	0x27, 0xb5, 0x95, 0x74, 0x60, 0x04, 0x47, 0x59, 0x28, 0x9e, 0xd9, 0x3e, 0x80, 0xd2, 0xb3, 0xd3,
	0xc1, 0xcc, 0x8c, 0x4e, 0x68, 0xdd, 0x56, 0x2a, 0x0f, 0x67, 0x28, 0xa0, 0x7f, 0x76, 0x7a, 0x80,
	0x24, 0xd2, 0x7f, 0x2c, 0xfb, 0xd4, 0x76, 0xfd, 0x99, 0x1d, 0x30, 0x98, 0x5f, 0x4a, 0x5f, 0x34,
	0x55, 0xbe, 0xd2, 0x7f, 0x62, 0x16, 0x85, 0xf6, 0x01, 0x34, 0x2c, 0x7b, 0x6c, 0xce, 0xdd, 0x68,
	0x10, 0x57, 0x61, 0x8d, 0x5a, 0xbb, 0x85, 0xd6, 0xde, 0x15, 0xd6, 0x54, 0x09, 0xd9, 0xde, 0x0a,
	0x67, 0xee, 0x70, 0x9e, 0xfe, 0xbb, 0x3c, 0xe4, 0x89, 0xdf, 0xbf, 0xee, 0x59, 0xae, 0xa5, 0x66,
	0x76, 0x36, 0x8d, 0xcc, 0xf3, 0x33, 0x5b, 0xc9, 0xe3, 0x9f, 0x40, 0xd9, 0x7f, 0xee, 0xa1, 0x53,
	0x70, 0x5f, 0xac, 0xd4, 0xb7, 0x17, 0xdd, 0x17, 0x8f, 0xa7, 0x50, 0x57, 0x1a, 0x02, 0x25, 0xe2,
	0x2c, 0x78, 0x0c, 0xda, 0x2c, 0xf0, 0xad, 0xf9, 0x88, 0xce, 0xca, 0x22, 0x85, 0x58, 0xb2, 0x7e,
	0x03, 0x6d, 0xdc, 0xe4, 0x13, 0xe5, 0x2b, 0x32, 0xb2, 0xb5, 0x4b, 0x09, 0x9b, 0x67, 0x97, 0xb6,
	0x0f, 0x0d, 0x27, 0x1c, 0xa0, 0x78, 0xc2, 0xa2, 0xb9, 0x5c, 0x96, 0x63, 0x94, 0x96, 0x90, 0x6d,
	0xd6, 0x9d, 0x70, 0xdf, 0x3b, 0x88, 0x59, 0xa9, 0xa1, 0xa3, 0xf8, 0x95, 0x87, 0x8e, 0xd2, 0x1b,
	0x0d, 0x1d, 0xff, 0x2a, 0x42, 0x95, 0x00, 0xc5, 0xb0, 0x5d, 0xdb, 0x0c, 0x6d, 0xcd, 0x20, 0xd9,
	0x4f, 0x1f, 0x07, 0x31, 0x6e, 0x1e, 0x2c, 0x1a, 0x1f, 0x88, 0x71, 0x83, 0x3b, 0xe5, 0x66, 0x30,
	0x24, 0x07, 0x50, 0x22, 0x53, 0x62, 0x32, 0xfe, 0x3f, 0x5c, 0xd4, 0x60, 0x3d, 0x99, 0x3a, 0xa9,
	0xd1, 0x22, 0x79, 0x42, 0x8b, 0x77, 0x92, 0xe2, 0xc8, 0x20, 0x24, 0x15, 0x87, 0xd3, 0x57, 0xca,
	0xe1, 0x8f, 0x61, 0x99, 0x5a, 0x98, 0xf2, 0xfe, 0x44, 0xd1, 0x90, 0xaa, 0x4f, 0x9c, 0xd5, 0xd6,
	0xd1, 0xd0, 0xba, 0xb4, 0xaa, 0xd0, 0x91, 0x1d, 0x58, 0x9b, 0xc8, 0xcd, 0xee, 0x21, 0x54, 0xf9,
	0x51, 0xa5, 0x6b, 0xdf, 0x5b, 0x68, 0x46, 0x13, 0x05, 0x33, 0x66, 0xd2, 0x8a, 0xc9, 0xde, 0x30,
	0x80, 0x63, 0x49, 0x71, 0x78, 0xc6, 0xab, 0x7c, 0x77, 0x51, 0xd7, 0x5c, 0x4b, 0x59, 0x1f, 0x2a,
	0xf3, 0x51, 0xbc, 0x4e, 0xfb, 0x0c, 0x43, 0xba, 0x2c, 0x42, 0xca, 0xbe, 0x4f, 0xb1, 0xab, 0x86,
	0x38, 0x3e, 0x8f, 0x7c, 0x9f, 0xb0, 0xda, 0xcd, 0x24, 0xfb, 0x15, 0x1d, 0x3c, 0x74, 0x20, 0xc9,
	0x69, 0x0e, 0x0e, 0x7d, 0xa6, 0xeb, 0xb0, 0x8b, 0xe4, 0x50, 0xb4, 0x89, 0xc7, 0x8b, 0x6e, 0x5e,
	0x4c, 0x86, 0x92, 0x09, 0x75, 0x32, 0x14, 0x0c, 0xdc, 0xfe, 0x23, 0x79, 0x29, 0x74, 0x30, 0xfb,
	0x22, 0x71, 0x15, 0xad, 0x5c, 0x4e, 0x5b, 0x21, 0x1e, 0x4e, 0x74, 0x5b, 0x34, 0x36, 0x0e, 0xde,
	0x1b, 0x05, 0x56, 0x20, 0x1d, 0x1b, 0x89, 0x89, 0x3e, 0xc3, 0x37, 0x91, 0xed, 0xef, 0xe1, 0x38,
	0x8a, 0x6d, 0x8d, 0x14, 0xe2, 0x2a, 0x3d, 0x5a, 0x0d, 0x95, 0xca, 0x4c, 0xe9, 0x2e, 0x19, 0x3f,
	0x19, 0x13, 0xe7, 0xa5, 0xba, 0x19, 0x8c, 0x4e, 0xf0, 0x36, 0x33, 0x18, 0xfb, 0xc1, 0x14, 0xb7,
	0x57, 0x3b, 0x47, 0x7c, 0x99, 0xcb, 0x3c, 0xa6, 0x22, 0xfa, 0x1f, 0x73, 0x50, 0x3d, 0x9a, 0xb9,
	0xbe, 0x69, 0x1d, 0xfa, 0xcf, 0x6c, 0x8f, 0xcc, 0xef, 0x11, 0x79, 0xe0, 0xe9, 0x26, 0xcd, 0x06,
	0x94, 0xac, 0xcc, 0xef, 0x94, 0x42, 0x6a, 0x87, 0xfd, 0x62, 0xe6, 0x04, 0x76, 0x48, 0x3c, 0x92,
	0x4d, 0xd7, 0x8e, 0x84, 0xa7, 0xd4, 0x0e, 0x4e, 0x46, 0xbf, 0x7c, 0x06, 0xa5, 0x79, 0x28, 0x97,
	0xe0, 0xd6, 0xa2, 0x91, 0xe3, 0x8d, 0x91, 0x6b, 0x2b, 0x8d, 0x91, 0xd0, 0x30, 0x37, 0x3f, 0x4b,
	0xb2, 0x3d, 0xff, 0x46, 0xb6, 0xb9, 0xb6, 0x7a, 0xd5, 0x65, 0x79, 0x8f, 0xed, 0xc7, 0xb3, 0x9f,
	0xc7, 0xf1, 0x2c, 0xa4, 0xdb, 0x8f, 0xc4, 0x54, 0xb2, 0x01, 0xe9, 0xc7, 0xf1, 0x6c, 0x54, 0x99,
	0x53, 0xdf, 0x0f, 0x22, 0x9f, 0xe7, 0x9c, 0x34, 0x00, 0xc6, 0x2c, 0x65, 0x56, 0x98, 0xf3, 0x60,
	0xe9, 0x37, 0xe1, 0xd2, 0xb6, 0x1d, 0xf1, 0x4f, 0xa6, 0x86, 0x8d, 0x2d, 0x0d, 0x0b, 0x40, 0x3d,
	0x69, 0xb1, 0xa4, 0x47, 0xea, 0x77, 0x60, 0x05, 0x85, 0xe8, 0x1d, 0x5a, 0x88, 0xbc, 0x0d, 0xe5,
	0x11, 0x79, 0x8f, 0x6b, 0xaa, 0x51, 0xa2, 0xef, 0x3d, 0x4b, 0xff, 0x14, 0xae, 0x0b, 0xe9, 0xc0,
	0xf6, 0x1e, 0x07, 0xfe, 0x34, 0x65, 0xfe, 0x3a, 0xc0, 0x8c, 0x51, 0x12, 0xed, 0x0a, 0xa7, 0xa0,
	0xfe, 0x0f, 0xe0, 0x1a, 0xfb, 0xf2, 0x43, 0x4d, 0xb4, 0xe2, 0xcf, 0x41, 0x5f, 0xbe, 0xb4, 0xf6,
	0x96, 0xfa, 0x39, 0x4d, 0xdc, 0xcb, 0xf5, 0x27, 0xb0, 0x7e, 0xd1, 0x96, 0xc2, 0x99, 0xef, 0x61,
	0x97, 0x78, 0x9f, 0x1b, 0x0d, 0x28, 0x68, 0xc9, 0xb0, 0x57, 0x93, 0x3f, 0x1d, 0x18, 0x31, 0x57,
	0xff, 0x25, 0xac, 0xa2, 0x2d, 0xa9, 0xc3, 0x88, 0x7d, 0x5d, 0x4d, 0x60, 0xc2, 0xb6, 0x25, 0x62,
	0xdc, 0x4c, 0x6a, 0x7b, 0x96, 0xed, 0x57, 0xd4, 0x71, 0xe5, 0x03, 0x7b, 0xfd, 0xfe, 0x5a, 0x5c,
	0xc0, 0xa8, 0x45, 0xb9, 0x8e, 0xf1, 0x0f, 0xec, 0xfa, 0x18, 0xb4, 0x3e, 0xb9, 0xe9, 0xb3, 0x8b,
	0xfe, 0x02, 0x2e, 0x51, 0x9d, 0x9d, 0x4d, 0x39, 0x9b, 0x78, 0x8c, 0x7d, 0x4d, 0xa0, 0x5b, 0x40,
	0x8f, 0xb1, 0x37, 0xfd, 0xd7, 0x59, 0x68, 0xc4, 0xdf, 0x4b, 0x16, 0x58, 0xe6, 0x6a, 0xaa, 0x23,
	0xc6, 0x87, 0x7f, 0x08, 0xf9, 0xe8, 0x6c, 0x26, 0x4e, 0x78, 0x53, 0xea, 0x50, 0xb2, 0x69, 0x71,
	0xe4, 0x43, 0x14, 0x35, 0xa8, 0x82, 0xb6, 0x96, 0xfe, 0x54, 0x29, 0x4d, 0xb8, 0x57, 0xa0, 0xc0,
	0xbe, 0x80, 0x92, 0x7c, 0x29, 0x18, 0xec, 0x45, 0xdf, 0x85, 0xaa, 0x64, 0x46, 0x2b, 0x41, 0xae,
	0xd5, 0xe9, 0x34, 0x96, 0xb4, 0x1a, 0x94, 0x5b, 0x5b, 0x87, 0xbd, 0xe3, 0xd6, 0x61, 0xb7, 0x91,
	0x41, 0x70, 0x43, 0xa7, 0x1b, 0xbf, 0x67, 0x09, 0xb7, 0xdf, 0x3d, 0x3c, 0xec, 0xed, 0x6d, 0xf7,
	0x1b, 0x39, 0xad, 0x02, 0x85, 0xde, 0x5e, 0xa7, 0xfb, 0xc3, 0x46, 0x5e, 0x77, 0x60, 0xe5, 0x60,
	0x3e, 0x74, 0x9d, 0xf0, 0x24, 0x46, 0x89, 0xc6, 0x0f, 0x93, 0xa1, 0xcb, 0xb2, 0x7d, 0x62, 0x74,
	0xf9, 0x4f, 0x3b, 0x22, 0xba, 0xfc, 0x15, 0x31, 0xc5, 0xab, 0x60, 0x8e, 0x76, 0x67, 0x8d, 0x9f,
	0x5d, 0x2a, 0x94, 0xbc, 0xfa, 0xe9, 0xbf, 0x82, 0x95, 0x63, 0x5e, 0xe4, 0xbf, 0x14, 0x4d, 0xef,
	0x02, 0xed, 0xd6, 0x03, 0x15, 0x52, 0x55, 0x42, 0x3b, 0x8e, 0x61, 0x55, 0x21, 0x75, 0x43, 0x86,
	0xd6, 0x79, 0xbd, 0xd1, 0x28, 0xa3, 0x14, 0x7d, 0xc2, 0x04, 0xa9, 0xc7, 0xa0, 0x66, 0xeb, 0x6f,
	0x9c, 0x73, 0xe3, 0x55, 0xa6, 0xde, 0x8b, 0x22, 0xae, 0xff, 0x27, 0x03, 0x8d, 0x1d, 0x27, 0xa4,
	0xd6, 0x42, 0x61, 0x6e, 0x3b, 0xdd, 0xb2, 0x33, 0x74, 0x5b, 0x3a, 0xdf, 0x56, 0x5a, 0x7e, 0xb3,
	0xe7, 0xe1, 0xf0, 0xcb, 0x76, 0xa9, 0xf6, 0x69, 0x0c, 0xbd, 0xeb, 0x60, 0x25, 0xa3, 0x8b, 0x62,
	0xe8, 0xe9, 0x0b, 0x81, 0xb1, 0x3f, 0x1e, 0x23, 0x3e, 0xd8, 0x37, 0x71, 0x83, 0xbf, 0xe9, 0x53,
	0x80, 0xc4, 0x12, 0x45, 0xc4, 0xde, 0x8f, 0x10, 0x11, 0x55, 0x28, 0x6d, 0x19, 0x5d, 0x8c, 0x7f,
	0x07, 0x01, 0xb1, 0x02, 0xd5, 0x4e, 0xf7, 0xb8, 0xbb, 0xb3, 0x7f, 0xb0, 0xdb, 0xdd, 0x3b, 0x44,
	0x44, 0x20, 0xf7, 0x69, 0xab, 0x47, 0x10, 0x81, 0x80, 0x40, 0x78, 0x18, 0xdd, 0x27, 0xdd, 0x2d,
	0x22, 0x9b, 0xd7, 0x96, 0xa1, 0x72, 0xdc, 0xda, 0xe9, 0x75, 0xa8, 0x6a, 0x81, 0x60, 0xe9, 0xc0,
	0xd8, 0xef, 0x1c, 0x21, 0x9a, 0xf6, 0xf7, 0x1a, 0x45, 0xfd, 0x37, 0x59, 0x28, 0x93, 0xa3, 0xf4,
	0xb0, 0xd0, 0x5e, 0x1c, 0xc1, 0x8d, 0x73, 0xae, 0x1c, 0x8a, 0x6b, 0x6f, 0x41, 0xdd, 0xc5, 0xfd,
	0x86, 0x49, 0x9f, 0xa7, 0x3d, 0xcd, 0x58, 0x66, 0x54, 0x11, 0xe6, 0x0f, 0xc9, 0xbc, 0x4c, 0xc5,
	0x98, 0x4b, 0xf3, 0x17, 0x47, 0xba, 0xca, 0x04, 0x99, 0x1b, 0xee, 0x9e, 0x7b, 0xa1, 0xa0, 0xad,
	0xe7, 0xbc, 0x7b, 0x42, 0x33, 0x99, 0x1c, 0x8a, 0x0c, 0xe0, 0x62, 0x56, 0xb8, 0xf5, 0xca, 0xac,
	0x50, 0x62, 0xfb, 0x54, 0xa7, 0x83, 0x09, 0x34, 0x11, 0x5c, 0x3b, 0xf2, 0xde, 0x63, 0x5c, 0xc4,
	0x15, 0x30, 0xb3, 0x60, 0x05, 0x24, 0x45, 0x88, 0xbb, 0x35, 0x44, 0xd7, 0xe5, 0xc8, 0x7e, 0x98,
	0x5f, 0x43, 0xdd, 0x42, 0x14, 0xe3, 0x63, 0xcb, 0xb3, 0xc4, 0xde, 0xdf, 0xa0, 0x26, 0x63, 0x74,
	0x22, 0x33, 0x18, 0x9a, 0xae, 0x3b, 0x98, 0x07, 0x2e, 0xf7, 0x3c, 0x70, 0xd2, 0x51, 0xe0, 0xea,
	0xdb, 0x70, 0x65, 0x3b, 0x49, 0xb6, 0x30, 0x2e, 0x0e, 0xf7, 0xa0, 0x84, 0xb3, 0x08, 0xde, 0x59,
	0x43, 0xde, 0x41, 0x56, 0xa5, 0x62, 0x97, 0xec, 0xc9, 0x10, 0x52, 0x7a, 0x1d, 0x6a, 0xf4, 0x57,
	0x19, 0x7e, 0x58, 0xfd, 0x13, 0xa8, 0xf5, 0x6d, 0xe2, 0x3a, 0x83, 0x0a, 0x5c, 0xbc, 0x79, 0xcc,
	0x81, 0x70, 0xe4, 0x07, 0x0c, 0x3a, 0x19, 0x83, 0xbd, 0xe8, 0x4f, 0x61, 0x59, 0xa8, 0x33, 0xdf,
	0xa2, 0x18, 0x3e, 0x04, 0x67, 0x5c, 0x9b, 0xbd, 0x24, 0x1e, 0xcf, 0x2e, 0xda, 0x73, 0xfa, 0x50,
	0x8f, 0xf7, 0x75, 0x71, 0x1d, 0xbc, 0x9b, 0x1c, 0x3f, 0xab, 0x7c, 0x2d, 0x91, 0xcf, 0x94, 0x1c,
	0xfe, 0x23, 0xcc, 0xab, 0x37, 0x2a, 0xab, 0xb7, 0xbf, 0x05, 0x45, 0xf6, 0x63, 0x02, 0x49, 0xd4,
	0xa3, 0xbd, 0xef, 0xef, 0xed, 0x3f, 0xdd, 0xc3, 0x9c, 0x2e, 0x43, 0x7e, 0xb7, 0xb5, 0x43, 0x2a,
	0x3c, 0x40, 0xf1, 0x71, 0x97, 0x3e, 0x67, 0x6f, 0x8f, 0xa1, 0x26, 0x1f, 0x49, 0xce, 0xfc, 0xa5,
	0x74, 0xe6, 0x67, 0xe4, 0xcc, 0xcf, 0x2a, 0x99, 0x9f, 0x53, 0x33, 0x3f, 0x9f, 0xca, 0xfc, 0xc2,
	0xed, 0x8f, 0xe1, 0xf2, 0x39, 0x1e, 0xc4, 0x10, 0x34, 0x12, 0xb1, 0x41, 0xff, 0x90, 0xb4, 0x9c,
	0x25, 0xa2, 0xdc, 0xda, 0xd9, 0x61, 0xaf, 0xfd, 0x46, 0xa6, 0xbd, 0xf6, 0xf2, 0xef, 0xeb, 0x4b,
	0x2f, 0xff, 0xb1, 0x9e, 0xf9, 0x33, 0xfe, 0xfd, 0x0d, 0xff, 0x3e, 0xff, 0xe7, 0xfa, 0xd2, 0x6f,
	0xb3, 0xb9, 0xfd, 0xc3, 0xfe, 0xb0, 0x48, 0xff, 0x23, 0xe0, 0xc1, 0xff, 0x02, 0x00, 0x00, 0xff,
	0xff, 0x0f, 0xfb, 0x3e, 0xca, 0x40, 0x20, 0x00, 0x00,
}
